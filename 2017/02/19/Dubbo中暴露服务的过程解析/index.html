<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="dubbo源码,dubbo服务暴露," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=”-1”）：

设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo中暴露服务的过程解析">
<meta property="og:url" content="http://dachengxi.github.com/2017/02/19/Dubbo中暴露服务的过程解析/index.html">
<meta property="og:site_name" content="大程熙">
<meta property="og:description" content="dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=”-1”）：

设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行">
<meta property="og:updated_time" content="2017-04-23T04:24:01.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dubbo中暴露服务的过程解析">
<meta name="twitter:description" content="dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=”-1”）：

设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://dachengxi.github.com/2017/02/19/Dubbo中暴露服务的过程解析/"/>





  <title> Dubbo中暴露服务的过程解析 | 大程熙 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大程熙</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小角落</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-book">
          <a href="/book" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            读书
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dachengxi.github.com/2017/02/19/Dubbo中暴露服务的过程解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dachengxi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大程熙">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Dubbo中暴露服务的过程解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-19T00:46:14+08:00">
                2017-02-19 00:46:14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index">
                    <span itemprop="name">dubbo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/19/Dubbo中暴露服务的过程解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/02/19/Dubbo中暴露服务的过程解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=”-1”）：</p>
<ul>
<li>设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。</li>
<li>没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务。</li>
</ul>
<p>但是不管延迟与否，都是使用ServiceConfig的export()方法进行服务的暴露。使用export初始化的时候会将Bean对象转换成URL格式，所有Bean属性转换成URL的参数。<br><a id="more"></a><br>以没有设置延迟暴露熟属性的过程为例。</p>
<h1 id="简易的暴露流程"><a href="#简易的暴露流程" class="headerlink" title="简易的暴露流程"></a>简易的暴露流程</h1><ol>
<li>首先将服务的实现封装成一个Invoker，Invoker中封装了服务的实现类。</li>
<li>将Invoker封装成Exporter，并缓存起来，缓存里使用Invoker的url作为key。</li>
<li>服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）</li>
</ol>
<h1 id="Spring容器初始化调用"><a href="#Spring容器初始化调用" class="headerlink" title="Spring容器初始化调用"></a>Spring容器初始化调用</h1><p>当Spring容器实例化bean完成，走到最后一步发布ContextRefreshEvent事件的时候，ServiceBean会执行onApplicationEvent方法，该方法调用ServiceConfig的export方法。</p>
<p>ServiceConfig初始化的时候，会先初始化静态变量protocol和proxyFactory，这两个变量初始化的结果是通过dubbo的spi扩展机制得到的。</p>
<p>生成的protocol实例是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.alibaba.dubbo.rpc;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line">public class Protocol$Adpative implements com.alibaba.dubbo.rpc.Protocol &#123;</span><br><span class="line">    public com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws java.lang.Class &#123;</span><br><span class="line">        if (arg1 == null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg1;</span><br><span class="line">        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line">        if(extName == null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.Invoker &#123;</span><br><span class="line">        if (arg0 == null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument == null&quot;);</span><br><span class="line"></span><br><span class="line">        if (arg0.getUrl() == null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&quot;);com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line">        //根据URL配置信息获取Protocol协议，默认是dubbo</span><br><span class="line">        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line">        if(extName == null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line">            //根据协议名，获取Protocol的实现</span><br><span class="line">            //获得Protocol的实现过程中，会对Protocol先进行依赖注入，然后进行Wrapper包装，最后返回被修改过的Protocol</span><br><span class="line">            //包装经过了ProtocolFilterWrapper，ProtocolListenerWrapper，RegistryProtocol</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDefaultPort() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的proxyFactory实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.alibaba.dubbo.rpc;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class ProxyFactory$Adpative implements com.alibaba.dubbo.rpc.ProxyFactory &#123;</span><br><span class="line">    public com.alibaba.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2) throws java.lang.Object &#123;</span><br><span class="line">        if (arg2 == null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg2;</span><br><span class="line">        String extName = url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">        if(extName == null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.Invoker &#123;</span><br><span class="line">        if (arg0 == null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument == null&quot;);</span><br><span class="line"></span><br><span class="line">       if (arg0.getUrl() == null) </span><br><span class="line">        throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&quot;);com.alibaba.dubbo.common.URL url = arg0.getUrl();</span><br><span class="line"></span><br><span class="line">        String extName = url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">        if(extName == null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.rpc.ProxyFactory extension = (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的代码中可以看到，默认的Protocol实现是dubbo，默认的proxy是javassist。</p>
<h1 id="ServiceConfig的export"><a href="#ServiceConfig的export" class="headerlink" title="ServiceConfig的export"></a>ServiceConfig的export</h1><h2 id="export的步骤简介"><a href="#export的步骤简介" class="headerlink" title="export的步骤简介"></a>export的步骤简介</h2><ol>
<li>首先会检查各种配置信息，填充各种属性，总之就是保证我在开始暴露服务之前，所有的东西都准备好了，并且是正确的。</li>
<li>加载所有的注册中心，因为我们暴露服务需要注册到注册中心中去。</li>
<li>根据配置的所有协议和注册中心url分别进行导出。</li>
<li>进行导出的时候，又是一波属性的获取设置检查等操作。</li>
<li>如果配置的不是remote，则做本地导出。</li>
<li>如果配置的不是local，则暴露为远程服务。</li>
<li>不管是本地还是远程服务暴露，首先都会获取Invoker。</li>
<li>获取完Invoker之后，转换成对外的Exporter，缓存起来。</li>
</ol>
<p>export方法先判断是否需要延迟暴露（这里我们使用的是不延迟暴露），然后执行doExport方法。</p>
<p>doExport方法先执行一系列的检查方法，然后调用doExportUrls方法。检查方法会检测dubbo的配置是否在Spring配置文件中声明，没有的话读取properties文件初始化。</p>
<p>doExportUrls方法先调用loadRegistries获取所有的注册中心url，然后遍历调用doExportUrlsFor1Protocol方法。对于在标签中指定了registry属性的Bean，会在加载BeanDefinition的时候就加载了注册中心。</p>
<p>获取注册中心url，会把注册的信息都放在一个URL对象中，一个URL内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=dubbo-provider&amp;application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;organization=china&amp;owner=cheng.xi&amp;pid=2939&amp;registry=zookeeper&amp;timestamp=1488898049284</span><br></pre></td></tr></table></figure>
<p>doExportUrlsFor1Protocol根据不同的协议将服务以URL形式暴露。如果scope配置为none则不暴露，如果服务未配置成remote，则本地暴露exportLocal，如果未配置成local，则注册服务registryProcotol。</p>
<p> 这里的URL是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.1.100:20880/dubbo.common.hello.service.HelloService?anyhost=true&amp;application=dubbo-provider&amp;application.version=1.0&amp;delay=5000&amp;dubbo=2.5.3&amp;environment=product&amp;interface=dubbo.common.hello.service.HelloService&amp;methods=sayHello&amp;organization=china&amp;owner=cheng.xi&amp;pid=2939&amp;side=provider&amp;timestamp=1488898464953</span><br></pre></td></tr></table></figure>
<h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><p>这时候会先做本地暴露，exportLocal(url);：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void exportLocal(URL url) &#123;</span><br><span class="line">    if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">    	//这时候转成本地暴露的url：injvm://127.0.0.1/dubbo.common.hello.service.HelloService?anyhost=true&amp;</span><br><span class="line">        //application=dubbo-provider&amp;application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;</span><br><span class="line">        //interface=dubbo.common.hello.service.HelloService&amp;methods=sayHello&amp;</span><br><span class="line">        //organization=china&amp;owner=cheng.xi&amp;pid=720&amp;side=provider&amp;timestamp=1489716708276</span><br><span class="line">        URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                .setHost(NetUtils.LOCALHOST)</span><br><span class="line">                .setPort(0);</span><br><span class="line">        //首先还是先获得Invoker</span><br><span class="line">        //然后导出成Exporter，并缓存</span><br><span class="line">        //这里的proxyFactory实际是JavassistProxyFactory</span><br><span class="line">        //有关详细的获得Invoke以及exporter会在下面的流程解析，在本地暴露这个流程就不再说明。</span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class="line">                proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">        logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() +&quot; to local registry&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴露为远程服务"><a href="#暴露为远程服务" class="headerlink" title="暴露为远程服务"></a>暴露为远程服务</h3><p>接下来是暴露为远程服务，跟本地暴露的流程一样还是先获取Invoker，然后导出成Exporter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//根据服务具体实现，实现接口，以及registryUrl通过ProxyFactory将HelloServiceImpl封装成一个本地执行的Invoker</span><br><span class="line">//invoker是对具体实现的一种代理。</span><br><span class="line">//这里proxyFactory是上面列出的生成的代码</span><br><span class="line"> Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"> //使用Protocol将invoker导出成一个Exporter</span><br><span class="line"> //暴露封装服务invoker</span><br><span class="line"> //调用Protocol生成的适配类的export方法</span><br><span class="line"> //这里的protocol是上面列出的生成的代码</span><br><span class="line"> Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br></pre></td></tr></table></figure>
<p><strong>关于Invoker，Exporter等的解释参见最下面的内容。</strong></p>
<h1 id="暴露远程服务时的获取Invoker过程"><a href="#暴露远程服务时的获取Invoker过程" class="headerlink" title="暴露远程服务时的获取Invoker过程"></a>暴露远程服务时的获取Invoker过程</h1><p>服务实现类转换成Invoker，大概的步骤是：</p>
<ol>
<li>根据上面生成的proxyFactory方法调用具体的ProxyFactory实现类的getInvoker方法获取Invoker。</li>
<li>getInvoker的过程是，首先对实现类做一个包装，生成一个包装后的类。</li>
<li>然后新创建一个Invoker实例，这个Invoker中包含着生成的Wrapper类，Wrapper类中有具体的实现类。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure>
<p>这行代码中包含服务实现类转换成Invoker的过程，其中proxyFactory是上面列出的动态生成的代码，其中getInvoker的代码为（做了精简，把包都去掉了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Invoker getInvoker(Object arg0, Class arg1, URL arg2) throws Object &#123;</span><br><span class="line">    if (arg2 == null)  throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">	//传进来的url是dubbo://192.168.110.197:20880/dubbo.common.hello.service.HelloService?anyhost=true&amp;application=dubbo-provider</span><br><span class="line">    //&amp;application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;interface=dubbo.common.hello.service.HelloService&amp;methods=sayHello&amp;organization=china&amp;owner=cheng.xi</span><br><span class="line">    //&amp;pid=28191&amp;side=provider&amp;timestamp=1489027396094</span><br><span class="line">    URL url = arg2;</span><br><span class="line">    //没有proxy参数配置，默认使用javassist</span><br><span class="line">    String extName = url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">    if(extName == null)  throw new IllegalStateException(&quot;Fail to get extension(ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line">	//这一步就使用javassist来获取ProxyFactory的实现类JavassistProxyFactory</span><br><span class="line">    ProxyFactory extension = (ProxyFactory)ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName);</span><br><span class="line">	//JavassistProxyFactory的getInvoker方法</span><br><span class="line">    return extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用JavassistProxyFactory获取Invoker"><a href="#使用JavassistProxyFactory获取Invoker" class="headerlink" title="使用JavassistProxyFactory获取Invoker"></a>使用JavassistProxyFactory获取Invoker</h2><p>JavassistProxyFactory的getInvoker方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    // TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">    //第一步封装一个Wrapper类</span><br><span class="line">    //该类是手动生成的</span><br><span class="line">    //如果类是以$开头，就使用接口类型获取，其他的使用实现类获取</span><br><span class="line">    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">    //返回一个Invoker实例，doInvoke方法中直接返回上面wrapper的invokeMethod</span><br><span class="line">    //关于生成的wrapper，请看下面列出的生成的代码，其中invokeMethod方法中就有实现类对实际方法的调用</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成wrapper类的过程，首先看getWrapper方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static Wrapper getWrapper(Class&lt;?&gt; c)&#123;</span><br><span class="line">    while( ClassGenerator.isDynamicClass(c) ) // can not wrapper on dynamic class.</span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line">	//Object类型的</span><br><span class="line">    if( c == Object.class )</span><br><span class="line">        return OBJECT_WRAPPER;</span><br><span class="line">	//先去Wrapper缓存中查找</span><br><span class="line">    Wrapper ret = WRAPPER_MAP.get(c);</span><br><span class="line">    if( ret == null ) &#123;</span><br><span class="line">    	//缓存中不存在，生成Wrapper类，放到缓存</span><br><span class="line">        ret = makeWrapper(c);</span><br><span class="line">        WRAPPER_MAP.put(c,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeWrapper方法代码不在列出，太长了。就是生成一个继承自Wrapper的类，最后的结果大概是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper1 extends Wrapper &#123;</span><br><span class="line">    public static String[] pns;</span><br><span class="line">    public static Map pts;</span><br><span class="line">    public static String[] mns; // all method name array.</span><br><span class="line">    public static String[] dmns;</span><br><span class="line">    public static Class[] mts0;</span><br><span class="line"></span><br><span class="line">    public String[] getPropertyNames() &#123;</span><br><span class="line">        return pns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasProperty(String n) &#123;</span><br><span class="line">        return pts.containsKey($1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class getPropertyType(String n) &#123;</span><br><span class="line">        return (Class) pts.get($1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getMethodNames() &#123;</span><br><span class="line">        return mns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getDeclaredMethodNames() &#123;</span><br><span class="line">        return dmns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPropertyValue(Object o, String n, Object v) &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getPropertyValue(Object o, String n) &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (&quot;sayHello&quot;.equals($2) &amp;&amp; $3.length == 0) &#123;</span><br><span class="line">                w.sayHello();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot; + $2 + &quot;\&quot; in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成完Wrapper以后，返回一个AbstractProxyInvoker实例。至此生成Invoker的步骤就完成了。可以看到Invoker执行方法的时候，会调用Wrapper的invokeMethod，这个方法中会有真实的实现类调用真实方法的代码。</p>
<h2 id="使用JdkProxyFactory获取invoker"><a href="#使用JdkProxyFactory获取invoker" class="headerlink" title="使用JdkProxyFactory获取invoker"></a>使用JdkProxyFactory获取invoker</h2><p>JdkProxyFactory的getInvoker方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">            return method.invoke(proxy, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回一个AbstractProxyInvoker实例，没有做处理，只是使用反射调用具体的方法。</p>
<p>JdkProxyFactory的getProxy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Java的反射机制生成一个代理类。</p>
<h1 id="暴露远程服务时导出Invoker为Exporter"><a href="#暴露远程服务时导出Invoker为Exporter" class="headerlink" title="暴露远程服务时导出Invoker为Exporter"></a>暴露远程服务时导出Invoker为Exporter</h1><p>Invoker导出为Exporter分为两种情况，第一种是Registry类型的Invoker，第二种是其他协议类型的Invoker，分开解析。</p>
<p>代码入口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br></pre></td></tr></table></figure>
<h2 id="Registry类型的Invoker处理过程"><a href="#Registry类型的Invoker处理过程" class="headerlink" title="Registry类型的Invoker处理过程"></a>Registry类型的Invoker处理过程</h2><p>大概的步骤是：</p>
<ol>
<li>经过两个不用做任何处理的Wrapper类，然后到达RegistryProtocol中。</li>
<li>通过具体的协议导出Invoker为Exporter。</li>
<li>注册服务到注册中心。</li>
<li>订阅注册中心的服务。</li>
<li>生成一个新的Exporter实例，将上面的Exporter进行引入，然后返回。</li>
</ol>
<p>protocol是上面列出的动态生成的代码，会先调用ProtocolListenerWrapper，这个Wrapper负责初始化暴露和引用服务的监听器。对于Registry类型的不做处理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	//registry类型的Invoker，不需要做处理</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    //非Registry类型的Invoker，需要被监听器包装</span><br><span class="line">    return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), </span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用ProtocolFilterWrapper中的export方法，ProtocolFilterWrapper负责初始化invoker所有的Filter。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	//Registry类型的Invoker不做处理</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    //非Registry类型的Invoker需要先构建调用链，然后再导出</span><br><span class="line">    return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先解析的是Registry类型的Invoker，接着就会调用RegistryProtocol的export方法，RegistryProtocol负责注册服务到注册中心和向注册中心订阅服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;</span><br><span class="line">    //export invoker</span><br><span class="line">    //这里就交给了具体的协议去暴露服务（先不解析，留在后面，可以先去后面看下导出过程）</span><br><span class="line">    final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">    //registry provider</span><br><span class="line">    //根据invoker中的url获取Registry实例</span><br><span class="line">    //并且连接到注册中心</span><br><span class="line">    //此时提供者作为消费者引用注册中心核心服务RegistryService</span><br><span class="line">    final Registry registry = getRegistry(originInvoker);</span><br><span class="line">    //注册到注册中心的URL</span><br><span class="line">    final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">    //调用远端注册中心的register方法进行服务注册</span><br><span class="line">    //若有消费者订阅此服务，则推送消息让消费者引用此服务。</span><br><span class="line">    //注册中心缓存了所有提供者注册的服务以供消费者发现。</span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">    // 订阅override数据</span><br><span class="line">    // FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span><br><span class="line">    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    //提供者向注册中心订阅所有注册服务的覆盖配置</span><br><span class="line">    //当注册中心有此服务的覆盖配置注册进来时，推送消息给提供者，重新暴露服务，这由管理页面完成。</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    //保证每次export都返回一个新的exporter实例</span><br><span class="line">    //返回暴露后的Exporter给上层ServiceConfig进行缓存，便于后期撤销暴露。</span><br><span class="line">    return new Exporter&lt;T&gt;() &#123;</span><br><span class="line">        public Invoker&lt;T&gt; getInvoker() &#123;</span><br><span class="line">            return exporter.getInvoker();</span><br><span class="line">        &#125;</span><br><span class="line">        public void unexport() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                exporter.unexport();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                registry.unregister(registedProviderUrl);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                overrideListeners.remove(overrideSubscribeUrl);</span><br><span class="line">                registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交给具体的协议去暴露服务"><a href="#交给具体的协议去暴露服务" class="headerlink" title="交给具体的协议去暴露服务"></a>交给具体的协议去暴露服务</h3><p>先不解析，留在后面，可以先去后面看下导出过程，然后再回来接着看注册到注册中心的过程。具体协议暴露服务主要是打开服务器和端口，进行监听。</p>
<h3 id="连接注册中心并获取Registry实例"><a href="#连接注册中心并获取Registry实例" class="headerlink" title="连接注册中心并获取Registry实例"></a>连接注册中心并获取Registry实例</h3><p>具体的协议进行暴露并且返回了一个ExporterChangeableWrapper之后，接下来看下一步连接注册中心并注册到注册中心，代码是在RegistryProtocol的export方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//先假装此步已经分析完</span><br><span class="line">final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line">//得到具体的注册中心，连接注册中心，此时提供者作为消费者引用注册中心核心服务RegistryService</span><br><span class="line">final Registry registry = getRegistry(originInvoker);</span><br><span class="line">final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">//调用远端注册中心的register方法进行服务注册</span><br><span class="line">//若有消费者订阅此服务，则推送消息让消费者引用此服务</span><br><span class="line">registry.register(registedProviderUrl);</span><br><span class="line">//提供者向注册中心订阅所有注册服务的覆盖配置</span><br><span class="line">registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">//返回暴露后的Exporter给上层ServiceConfig进行缓存</span><br><span class="line">return new Exporter&lt;T&gt;() &#123;。。。&#125;</span><br></pre></td></tr></table></figure>
<p>getRegistry(originInvoker)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//根据invoker的地址获取registry实例</span><br><span class="line">private Registry getRegistry(final Invoker&lt;?&gt; originInvoker)&#123;</span><br><span class="line">	//获取invoker中的registryUrl</span><br><span class="line">    URL registryUrl = originInvoker.getUrl();</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) &#123;</span><br><span class="line">    	//获取registry的值，这里获得是zookeeper，默认值是dubbo</span><br><span class="line">        String protocol = registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);</span><br><span class="line">        //这里获取到的url为：</span><br><span class="line">        //zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">        //application=dubbo-provider&amp;application.version=1.0&amp;dubbo=2.5.3&amp;</span><br><span class="line">        //environment=product&amp;export=dubbo%3A%2F%2F192.168.1.100%3A20880%2F</span><br><span class="line">        //dubbo.common.hello.service.HelloService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">        //application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26</span><br><span class="line">        //interface%3Ddubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">        //organization%3Dchina%26owner%3Dcheng.xi%26pid%3D9457%26side%3Dprovider%26timestamp%3D1489807681627&amp;organization=china&amp;owner=cheng.xi&amp;</span><br><span class="line">        //pid=9457&amp;timestamp=1489807680193</span><br><span class="line">        registryUrl = registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据SPI机制获取具体的Registry实例，这里获取到的是ZookeeperRegistry</span><br><span class="line">    return registryFactory.getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的registryFactory是动态生成的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class RegistryFactory$Adpative implements com.alibaba.dubbo.registry.RegistryFactory &#123;</span><br><span class="line">    public com.alibaba.dubbo.registry.Registry getRegistry(com.alibaba.dubbo.common.URL arg0) &#123;</span><br><span class="line">    </span><br><span class="line">        if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.registry.RegistryFactory extension = (com.alibaba.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里registryFactory.getRegistry(registryUrl)用的是ZookeeperRegistryFactory。</p>
<p>先看下getRegistry方法，会发现该方法会在AbstractRegistryFactory中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Registry getRegistry(URL url) &#123;</span><br><span class="line">    url = url.setPath(RegistryService.class.getName())</span><br><span class="line">            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">    //这里key为：</span><br><span class="line">    //zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService</span><br><span class="line">    String key = url.toServiceString();</span><br><span class="line">    // 锁定注册中心获取过程，保证注册中心单一实例</span><br><span class="line">    LOCK.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">    	//先从缓存中获取Registry实例</span><br><span class="line">        Registry registry = REGISTRIES.get(key);</span><br><span class="line">        if (registry != null) &#123;</span><br><span class="line">            return registry;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建registry，会直接new一个ZookeeperRegistry返回</span><br><span class="line">        //具体创建实例是子类来实现的</span><br><span class="line">        registry = createRegistry(url);</span><br><span class="line">        if (registry == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can not create registry &quot; + url);</span><br><span class="line">        &#125;</span><br><span class="line">        //放到缓存中</span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        return registry;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createRegistry(url);是在子类中实现的，这里是ZookeeperRegistry，首先需要经过AbstractRegistry的构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public AbstractRegistry(URL url) &#123;</span><br><span class="line">	//url保存起来</span><br><span class="line">    setUrl(url);</span><br><span class="line">    // 启动文件保存定时器</span><br><span class="line">    //</span><br><span class="line">    syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);</span><br><span class="line">    //保存的文件为：</span><br><span class="line">    ///home/xxx/.dubbo/dubbo-registry-127.0.0.1.cache</span><br><span class="line">    String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(&quot;user.home&quot;) + &quot;/.dubbo/dubbo-registry-&quot; + url.getHost() + &quot;.cache&quot;);</span><br><span class="line">    File file = null;</span><br><span class="line">    if (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">        file = new File(filename);</span><br><span class="line">        if(! file.exists() &amp;&amp; file.getParentFile() != null &amp;&amp; ! file.getParentFile().exists())&#123;</span><br><span class="line">            if(! file.getParentFile().mkdirs())&#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid registry store file &quot; + file + &quot;, cause: Failed to create directory &quot; + file.getParentFile() + &quot;!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.file = file;</span><br><span class="line">    //加载文件中的属性</span><br><span class="line">    loadProperties();</span><br><span class="line">    //通知订阅</span><br><span class="line">    notify(url.getBackupUrls());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取Registry时的订阅"><a href="#获取Registry时的订阅" class="headerlink" title="获取Registry时的订阅"></a>获取Registry时的订阅</h3><p>notify()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    if(urls == null || urls.isEmpty()) return;</span><br><span class="line">	//getSubscribed()方法获取订阅者列表</span><br><span class="line">    //订阅者Entry里每个URL都对应着n个NotifyListener</span><br><span class="line">    for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : getSubscribed().entrySet()) &#123;</span><br><span class="line">        URL url = entry.getKey();</span><br><span class="line"></span><br><span class="line">        if(! UrlUtils.isMatch(url, urls.get(0))) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">        if (listeners != null) &#123;</span><br><span class="line">            for (NotifyListener listener : listeners) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                	//通知每个监听器</span><br><span class="line">                    notify(url, listener, filterEmpty(url, urls));</span><br><span class="line">                &#125; catch (Throwable t) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>notify(url, listener, filterEmpty(url, urls));</code>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; result = new HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line">    for (URL u : urls) &#123;</span><br><span class="line">        if (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">        	//分类</span><br><span class="line">            String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">            List&lt;URL&gt; categoryList = result.get(category);</span><br><span class="line">            if (categoryList == null) &#123;</span><br><span class="line">                categoryList = new ArrayList&lt;URL&gt;();</span><br><span class="line">                result.put(category, categoryList);</span><br><span class="line">            &#125;</span><br><span class="line">            categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.size() == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">    if (categoryNotified == null) &#123;</span><br><span class="line">        notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">        categoryNotified = notified.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category = entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        //保存到主目录下的.dubbo目录下</span><br><span class="line">        saveProperties(url);</span><br><span class="line">        //上面获取到的监听器进行通知</span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractRegistry构造器初始化完，接着调用FailbackRegistry构造器初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public FailbackRegistry(URL url) &#123;</span><br><span class="line">    super(url);</span><br><span class="line">    //重试时间，默认5000ms</span><br><span class="line">    int retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line">    //启动失败重试定时器</span><br><span class="line">    this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 检测并连接注册中心</span><br><span class="line">            try &#123;</span><br><span class="line">            	//重试方法由每个具体子类实现</span><br><span class="line">                //获取到注册失败的，然后尝试注册</span><br><span class="line">                retry();</span><br><span class="line">            &#125; catch (Throwable t) &#123; // 防御性容错&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后回到ZookeeperRegistry的构造初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123;</span><br><span class="line">    super(url);</span><br><span class="line">    if (url.isAnyHost()) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;registry address == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //获得到注册中心中的分组，默认dubbo</span><br><span class="line">    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    if (! group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    //注册到注册中心的节点</span><br><span class="line">    this.root = group;</span><br><span class="line">    //使用zookeeperTansporter去连接</span><br><span class="line">    //ZookeeperTransport这里是生成的自适应实现，默认使用ZkClientZookeeperTransporter</span><br><span class="line">    //ZkClientZookeeperTransporter的connect去实例化一个ZkClient实例</span><br><span class="line">    //并且订阅状态变化的监听器subscribeStateChanges</span><br><span class="line">    //然后返回一个ZkClientZookeeperClient实例</span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    //ZkClientZookeeperClient添加状态改变监听器</span><br><span class="line">    zkClient.addStateListener(new StateListener() &#123;</span><br><span class="line">        public void stateChanged(int state) &#123;</span><br><span class="line">            if (state == RECONNECTED) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取注册到注册中心的url"><a href="#获取注册到注册中心的url" class="headerlink" title="获取注册到注册中心的url"></a>获取注册到注册中心的url</h3><p>获取到了Registry，Registry实例中保存着连接到了zookeeper的zkClient实例之后，下一步获取要注册到注册中心的url（在RegistryProtocol中）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);</span><br><span class="line">//得到的URL是：</span><br><span class="line">//dubbo://192.168.1.100:20880/dubbo.common.hello.service.HelloService?</span><br><span class="line">//anyhost=true&amp;application=dubbo-provider&amp;application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;</span><br><span class="line">//interface=dubbo.common.hello.service.HelloService&amp;methods=sayHello&amp;</span><br><span class="line">//organization=china&amp;owner=cheng.xi&amp;pid=9457&amp;side=provider&amp;timestamp=1489807681627</span><br></pre></td></tr></table></figure>
<h3 id="注册到注册中心"><a href="#注册到注册中心" class="headerlink" title="注册到注册中心"></a>注册到注册中心</h3><p>然后调用<code>registry.register(registedProviderUrl)</code>注册到注册中心（在RegistryProtocol中）。register方法的实现在FailbackRegistry中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void register(URL url) &#123;</span><br><span class="line">    super.register(url);</span><br><span class="line">    failedRegistered.remove(url);</span><br><span class="line">    failedUnregistered.remove(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 向服务器端发送注册请求</span><br><span class="line">        //调用子类具体实现，发送注册请求</span><br><span class="line">        doRegister(url);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Throwable t = e;</span><br><span class="line"></span><br><span class="line">        // 如果开启了启动时检测，则直接抛出异常</span><br><span class="line">        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; ! Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">        boolean skipFailback = t instanceof SkipFailbackWrapperException;</span><br><span class="line">        if (check || skipFailback) &#123;</span><br><span class="line">            if(skipFailback) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            throw  。。。</span><br><span class="line">        &#125; else &#123; &#125;</span><br><span class="line"></span><br><span class="line">        // 将失败的注册请求记录到失败列表，定时重试</span><br><span class="line">        failedRegistered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doRegister(url);</code>在这里是ZookeeperRegistry中具体实现的，这里将会注册到注册中心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegister(URL url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    	//这里zkClient就是我们上面调用构造的时候生成的</span><br><span class="line">        //ZkClientZookeeperClient</span><br><span class="line">        //保存着连接到Zookeeper的zkClient实例</span><br><span class="line">        //开始注册，也就是在Zookeeper中创建节点</span><br><span class="line">        //这里toUrlPath获取到的path为：</span><br><span class="line">        ///dubbo/dubbo.common.hello.service.HelloService/providers/dubbo%3A%2F%2F192.168.1.100%3A20880%2F</span><br><span class="line">        //dubbo.common.hello.service.HelloService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">        //application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26interface%3D</span><br><span class="line">        //dubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">        //organization%3Dchina%26owner%3Dcheng.xi%26pid%3D8920%26side%3Dprovider%26timestamp%3D1489828029449</span><br><span class="line">        //默认创建的节点是临时节点</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));</span><br><span class="line">    &#125; catch (Throwable e) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这一步之后，Zookeeper中就有节点存在了，具体节点为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/dubbo</span><br><span class="line">	dubbo.common.hello.service.HelloService</span><br><span class="line">    	providers</span><br><span class="line">        	/dubbo/dubbo.common.hello.service.HelloService/providers/</span><br><span class="line">            dubbo%3A%2F%2F192.168.1.100%3A20880%2Fdubbo.common.hello.service.HelloService%3F</span><br><span class="line">            anyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">            application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26</span><br><span class="line">            interface%3Ddubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">            organization%3Dchina%26owner%3Dcheng.xi%26pid%3D13239%26side%3D</span><br><span class="line">            provider%26timestamp%3D1489829293525</span><br></pre></td></tr></table></figure>
<h3 id="订阅注册中心的服务"><a href="#订阅注册中心的服务" class="headerlink" title="订阅注册中心的服务"></a>订阅注册中心的服务</h3><p>在注册到注册中心之后，registry会去订阅覆盖配置的服务，这一步之后就会在<code>/dubbo/dubbo.common.hello.service/HelloService</code>节点下多一个configurators节点。（具体过程暂先不解析）。</p>
<h3 id="返回新Exporter实例"><a href="#返回新Exporter实例" class="headerlink" title="返回新Exporter实例"></a>返回新Exporter实例</h3><p>最后返回Exporter新实例，返回到ServiceConfig中。服务的发布就算完成了。</p>
<h2 id="交给具体的协议进行服务暴露"><a href="#交给具体的协议进行服务暴露" class="headerlink" title="交给具体的协议进行服务暴露"></a>交给具体的协议进行服务暴露</h2><p>这里也就是非Registry类型的Invoker的导出过程。主要的步骤是将本地ip和20880端口打开，进行监听。最后包装成exporter返回。</p>
<p>doLocalExport(invoker)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt;  doLocalExport(final Invoker&lt;T&gt; originInvoker)&#123;</span><br><span class="line">	//原始的invoker中的url：</span><br><span class="line">    //registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">    //application=dubbo-provider&amp;application.version=1.0&amp;dubbo=2.5.3</span><br><span class="line">    //&amp;environment=product&amp;export=dubbo%3A%2F%2F10.42.0.1%3A20880%2F</span><br><span class="line">    //dubbo.common.hello.service.HelloService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">    //application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26</span><br><span class="line">    //interface%3Ddubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">    //organization%3Dchina%26owner%3Dcheng.xi%26pid%3D7876%26side%3Dprovider%26timestamp%3D1489057305001&amp;</span><br><span class="line">    //organization=china&amp;owner=cheng.xi&amp;pid=7876&amp;registry=zookeeper&amp;timestamp=1489057304900</span><br><span class="line">    </span><br><span class="line">    //从原始的invoker中得到的key：</span><br><span class="line">    //dubbo://10.42.0.1:20880/dubbo.common.hello.service.HelloService?anyhost=true&amp;application=dubbo-provider&amp;</span><br><span class="line">    //application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;interface=dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">    //methods=sayHello&amp;organization=china&amp;owner=cheng.xi&amp;pid=7876&amp;side=provider&amp;timestamp=1489057305001</span><br><span class="line">    String key = getCacheKey(originInvoker);</span><br><span class="line">    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">    if (exporter == null) &#123;</span><br><span class="line">        synchronized (bounds) &#123;</span><br><span class="line">            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">            if (exporter == null) &#123;</span><br><span class="line">            	//得到一个Invoker代理，里面包含原来的Invoker</span><br><span class="line">                final Invoker&lt;?&gt; invokerDelegete = new InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">                //此处protocol还是最上面生成的代码，调用代码中的export方法，会根据协议名选择调用具体的实现类</span><br><span class="line">                //这里我们需要调用DubboProtocol的export方法</span><br><span class="line">                //这里的使用具体协议进行导出的invoker是个代理invoker</span><br><span class="line">                //导出完之后，返回一个新的ExporterChangeableWrapper实例</span><br><span class="line">                exporter = new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;)protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                bounds.put(key, exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (ExporterChangeableWrapper&lt;T&gt;) exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用dubbo协议导出"><a href="#使用dubbo协议导出" class="headerlink" title="使用dubbo协议导出"></a>使用dubbo协议导出</h3><p>这里<code>protocol.export(invokerDelegete)</code>就要去具体的DubboProtocol中执行了，DubboProtocol的外面包裹着ProtocolFilterWrapper，再外面还包裹着ProtocolListenerWrapper。会先经过ProtocolListenerWrapper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	//Registry类型的Invoker</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">   	//其他具体协议类型的Invoker</span><br><span class="line">    //先进行导出protocol.export(invoker)</span><br><span class="line">    //然后获取自适应的监听器</span><br><span class="line">    //最后返回的是包装了监听器的Exporter</span><br><span class="line">    //这里监听器的获取是getActivateExtension，如果指定了listener就加载实现，没有指定就不加载</span><br><span class="line">    return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), </span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再经过ProtocolFilterWrapper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	//Registry类型的Invoker</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    //其他具体协议类型的Invoker</span><br><span class="line">    //先构建Filter链，然后再导出</span><br><span class="line">    return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看下构建Invoker链的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123;</span><br><span class="line">	//我们要处理的那个Invoker作为处理链的最后一个</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    //根据key和group获取自动激活的Filter</span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    if (filters.size() &gt; 0) &#123;</span><br><span class="line">    	//把所有的过滤器都挨个连接起来，最后一个是我们真正的Invoker</span><br><span class="line">        for (int i = filters.size() - 1; i &gt;= 0; i --) &#123;</span><br><span class="line">            final Filter filter = filters.get(i);</span><br><span class="line">            final Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = new Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                public Class&lt;T&gt; getInterface() &#123;</span><br><span class="line">                    return invoker.getInterface();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public URL getUrl() &#123;</span><br><span class="line">                    return invoker.getUrl();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public boolean isAvailable() &#123;</span><br><span class="line">                    return invoker.isAvailable();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">                    return filter.invoke(next, invocation);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public void destroy() &#123;</span><br><span class="line">                    invoker.destroy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public String toString() &#123;</span><br><span class="line">                    return invoker.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就到了DubboProtocol的export方法，这里进行暴露服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	//dubbo://10.42.0.1:20880/dubbo.common.hello.service.HelloService?</span><br><span class="line">    //anyhost=true&amp;application=dubbo-provider&amp;</span><br><span class="line">    //application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;</span><br><span class="line">    //interface=dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">    //methods=sayHello&amp;organization=china&amp;owner=cheng.xi&amp;</span><br><span class="line">    //pid=7876&amp;side=provider&amp;timestamp=1489057305001</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    // export service.</span><br><span class="line">    //key由serviceName，port，version，group组成</span><br><span class="line">    //当nio客户端发起远程调用时，nio服务端通过此key来决定调用哪个Exporter，也就是执行的Invoker。</span><br><span class="line">    //dubbo.common.hello.service.HelloService:20880</span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    //将Invoker转换成Exporter</span><br><span class="line">    //直接new一个新实例</span><br><span class="line">    //没做啥处理，就是做一些赋值操作</span><br><span class="line">    //这里的exporter就包含了invoker</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    //缓存要暴露的服务，key是上面生成的</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    //export an stub service for dispaching event</span><br><span class="line">    //是否支持本地存根</span><br><span class="line">    //远程服务后，客户端通常只剩下接口，而实现全在服务器端，</span><br><span class="line">    //但提供方有些时候想在客户端也执行部分逻辑，比如：做ThreadLocal缓存，</span><br><span class="line">    //提前验证参数，调用失败后伪造容错数据等等，此时就需要在API中带上Stub，</span><br><span class="line">    //客户端生成Proxy实，会把Proxy通过构造函数传给Stub，</span><br><span class="line">    //然后把Stub暴露组给用户，Stub可以决定要不要去调Proxy。</span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY,Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);</span><br><span class="line">    if (isStubSupportEvent &amp;&amp; !isCallbackservice)&#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        if (stubServiceMethods == null || stubServiceMethods.length() == 0 )&#123;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//根据URL绑定IP与端口，建立NIO框架的Server</span><br><span class="line">    openServer(url);</span><br><span class="line"></span><br><span class="line">    return exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面得到的Exporter会被放到缓存中去，key就是上面生成的，客户端就可以发请求根据key找到Exporter，然后找到invoker进行调用了。接下来是创建服务器并监听端口。</p>
<p>接着调用openServer方法创建NIO Server进行监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">    // find server.</span><br><span class="line">    //key是IP:PORT</span><br><span class="line">    //192.168.110.197:20880</span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    //client 也可以暴露一个只有server可以调用的服务。</span><br><span class="line">    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY,true);</span><br><span class="line">    if (isServer) &#123;</span><br><span class="line">    	</span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        //同一JVM中，同协议的服务，共享同一个Server，</span><br><span class="line">        //第一个暴露服务的时候创建server，</span><br><span class="line">        //以后相同协议的服务都使用同一个server</span><br><span class="line">        if (server == null) &#123;</span><br><span class="line">            serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	//同协议的服务后来暴露服务的则使用第一次创建的同一Server</span><br><span class="line">            //server支持reset,配合override功能使用</span><br><span class="line">            //accept、idleTimeout、threads、heartbeat参数的变化会引起Server的属性发生变化</span><br><span class="line">            //这时需要重新设置Server</span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看createServer方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//url为：</span><br><span class="line">//dubbo://192.168.110.197:20880/dubbo.common.hello.service.HelloService?</span><br><span class="line">//anyhost=true&amp;application=dubbo-provider&amp;</span><br><span class="line">//application.version=1.0&amp;dubbo=2.5.3&amp;environment=product&amp;</span><br><span class="line">//interface=dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">//methods=sayHello&amp;organization=china&amp;owner=cheng.xi&amp;</span><br><span class="line">//pid=720&amp;side=provider&amp;timestamp=1489716708276</span><br><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">    //默认开启server关闭时发送readonly事件</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">    //默认开启heartbeat</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">    //默认使用netty</span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">    if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class="line">        throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);</span><br><span class="line"></span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    try &#123;</span><br><span class="line">    	//Exchangers是门面类，里面封装的是Exchanger的逻辑。</span><br><span class="line">        //Exchanger默认只有一个实现HeaderExchanger.</span><br><span class="line">        //Exchanger负责数据交换和网络通信。</span><br><span class="line">        //从Protocol进入Exchanger，标志着程序进入了remote层。</span><br><span class="line">        //这里requestHandler是ExchangeHandlerAdapter</span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; catch (RemotingException e) &#123; &#125;</span><br><span class="line">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    if (str != null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        if (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            throw new RpcException(&quot;Unsupported client type: &quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exchangers.bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, &quot;exchange&quot;);</span><br><span class="line">    //getExchanger方法根据url获取到一个默认的实现HeaderExchanger</span><br><span class="line">    //调用HeaderExchanger的bind方法</span><br><span class="line">    return getExchanger(url).bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeaderExchanger的bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">	//直接返回一个HeaderExchangeServer</span><br><span class="line">    //先创建一个HeaderExchangeHandler</span><br><span class="line">    //再创建一个DecodeHandler</span><br><span class="line">    //最后调用Transporters.bind</span><br><span class="line">    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会先创建一个HeaderExchangerHandler，包含着ExchangeHandlerAdapter，接着创建一个DecodeHandler，会包含前面的handler，接下来调用Transporters的bind方法，返回一个Server，接着用HeaderExchangeServer包装一下，就返回给Protocol层了。</p>
<p>在HeaderExchangerServer包装的时候会启动心跳定时器<code>startHeatbeatTimer();</code>，暂不解析。</p>
<p>Transports的bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    if (handlers.length == 1) &#123;</span><br><span class="line">        handler = handlers[0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	//如果有多个handler的话，需要使用分发器包装下</span><br><span class="line">        handler = new ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    //getTransporter()获取一个Adaptive的Transporter</span><br><span class="line">    //然后调用bind方法（默认是NettyTransporter的bind方法）</span><br><span class="line">    return getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getTransporter()生成的Transporter的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Transporter$Adpative implements com.alibaba.dubbo.remoting.Transporter &#123;</span><br><span class="line">    public com.alibaba.dubbo.remoting.Server bind(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1) throws com.alibaba.dubbo.common.URL &#123;</span><br><span class="line">        if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        //Server默认使用netty</span><br><span class="line">        String extName = url.getParameter(&quot;server&quot;, url.getParameter(&quot;transporter&quot;, &quot;netty&quot;));</span><br><span class="line">        if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(&quot; + url.toString() + &quot;) use keys([server, transporter])&quot;);</span><br><span class="line">        //获取到一个NettyTransporter</span><br><span class="line">        com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</span><br><span class="line">        //调用NettyTransporter的bind方法</span><br><span class="line">        return extension.bind(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public com.alibaba.dubbo.remoting.Client connect(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1) throws com.alibaba.dubbo.common.URL &#123;</span><br><span class="line">    if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">    com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">    </span><br><span class="line">    String extName = url.getParameter(&quot;client&quot;, url.getParameter(&quot;transporter&quot;, &quot;netty&quot;));</span><br><span class="line">    </span><br><span class="line">    if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(&quot; + url.toString() + &quot;) use keys([client, transporter])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.connect(arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NettyTransporter的bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line"> 	//创建一个Server</span><br><span class="line">    return new NettyServer(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public NettyServer(URL url, ChannelHandler handler) throws RemotingException&#123;</span><br><span class="line">	//handler先经过ChannelHandlers的包装方法</span><br><span class="line">    //然后再初始化</span><br><span class="line">    super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelHandlers.wrap方法中会根据SPI扩展机制动态生成Dispatcher的自适应类，生成的代码不在列出，默认使用AllDispatcher处理，会返回一个AllChannelHandler，会把线程池和DataStore都初始化了。然后经过HeartbeatHandler封装，再经过MultiMessageHandler封装后返回。</p>
<p>NettyServer构造，会依次经过AbstractPeer，AbstractEndpoint，AbstractServer，NettyServer的初始化。重点看下AbstractServer的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">    super(url, handler);</span><br><span class="line">    localAddress = getUrl().toInetSocketAddress();</span><br><span class="line">    String host = url.getParameter(Constants.ANYHOST_KEY, false) </span><br><span class="line">                    || NetUtils.isInvalidLocalHost(getUrl().getHost()) </span><br><span class="line">                    ? NetUtils.ANYHOST : getUrl().getHost();</span><br><span class="line">    bindAddress = new InetSocketAddress(host, getUrl().getPort());</span><br><span class="line">    this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">    this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">    try &#123;</span><br><span class="line">    	//初始化的时候会打开Server</span><br><span class="line">        //具体实现这里是NettyServer中</span><br><span class="line">        doOpen();</span><br><span class="line">    &#125; catch (Throwable t) &#123; &#125;</span><br><span class="line">    if (handler instanceof WrappedChannelHandler )&#123;</span><br><span class="line">        executor = ((WrappedChannelHandler)handler).getExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用doOpen方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    //boss线程池</span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true));</span><br><span class="line">    //worker线程池</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true));</span><br><span class="line">    //ChannelFactory，没有指定工作者线程数量，就使用cpu+1</span><br><span class="line">    ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">        public ChannelPipeline getPipeline() &#123;</span><br><span class="line">            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.this);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">            return pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // bind之后返回一个Channel</span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doOpen方法创建Netty的Server端并打开，具体的事情就交给Netty去处理了，Netty的过程，原理，代码有时间再另行研究。</p>
<ul>
<li>NIO框架接受到消息后，先由NettyCodecAdapter解码，再由NettyHandler处理具体的业务逻辑，再由NettyCodecAdapter编码后发送。</li>
<li>NettyServer既是Server又是Handler。</li>
<li>HeaderExchangerServer只是Server。</li>
<li>MultiMessageHandler是多消息处理Handler。</li>
<li>HeartbeatHandler是处理心跳事件的Handler。</li>
<li>AllChannelHandler是消息派发器，负责将请求放入线程池，并执行请求。</li>
<li>DecodeHandler是编解码Handler。</li>
<li>HeaderExchangerHandler是信息交换Handler，将请求转化成请求响应模式与同步转异步模式。</li>
<li>RequestHandler是最后执行的Handler，会在协议层选择Exporter后选择Invoker，进而执行Filter与Invoker，最终执行请求服务实现类方法。</li>
<li>Channel直接触发事件并执行Handler，Channel在有客户端连接Server的时候触发创建并封装成NettyChannel，再由HeaderExchangerHandler创建HeaderExchangerChannel，负责请求响应模式的处理。</li>
<li>NettyChannel其实是个Handler，HeaderExchangerChannel是个Channel，</li>
<li>消息的序列化与反序列化工作在NettyCodecAdapter中发起完成。</li>
</ul>
<p>当有客户端连接Server时的连接过程：</p>
<ul>
<li>NettyHandler.connected()</li>
<li>NettyServer.connected()</li>
<li>MultiMessageHandler.connected()</li>
<li>HeartbeatHandler.connected()</li>
<li>AllChannelHandler.connected()</li>
<li>DecodeHandler.connected()</li>
<li>HeaderExchangerHandler.connected()</li>
<li>requestHandler.connected()</li>
<li>执行服务的onconnect事件的监听方法</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h2><p>可执行的对象，执行具体的远程调用，能够根据方法名称，参数得到相应的执行结果。</p>
<p>Invocation，包含了需要执行的方法，参数等信息。目前实现类只有RpcInvocation。</p>
<p>有三种类型的Invoker：</p>
<ul>
<li>本地执行类的Invoker。</li>
<li>远程通信执行类的Invoker。</li>
<li>多个远程通信执行类的Invoker聚合成集群版的Invoker。</li>
</ul>
<p>以HelloService为例：</p>
<ul>
<li>本地执行类的Invoker：在Server端有HelloServiceImpl实现，要执行该接口，只需要通过反射执行对应的实现类即可。</li>
<li>远程通信执行类的Invoker：在Client端要想执行该接口的实现方法，需要先进行远程通信，发送要执行的参数信息给Server端，Server端利用本地执行Invoker的方式执行，最后将结果发送给Client。</li>
<li>集群版的Invoker：Client端使用的时候，通过集群版的Invoker操作，Invoker会挑选一个远程通信类型的Invoker来执行。</li>
</ul>
<p>提供者端的Invoker封装了服务实现类，URL，Type，状态都是只读并且线程安全。通过发起invoke来具体调用服务类。</p>
<h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><p>在服务提供者端，ProxyFactory主要服务的实现统一包装成一个Invoker，Invoker通过反射来执行具体的Service实现对象的方法。默认的实现是JavassistProxyFactory，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    // TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>服务地址的发布和订阅。</p>
<p>Protocol是dubbo中的服务域，只在服务启用时加载，无状态，线程安全，是实体域Invoker暴露和引用的主功能入口，负责Invoker的生命周期管理，是Dubbo中远程服务调用层。</p>
<p>Protocol根据指定协议对外公布服务，当客户端根据协议调用这个服务时，Protocol会将客户端传递过来的Invocation参数交给Invoker去执行。</p>
<p>Protocol加入了远程通信协议，会根据客户端的请求来获取参数Invocation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Extension(&quot;dubbo&quot;)</span><br><span class="line">public interface Protocol &#123;</span><br><span class="line"></span><br><span class="line">    int getDefaultPort();</span><br><span class="line"></span><br><span class="line">    //对于服务提供端，将本地执行类的Invoker通过协议暴漏给外部</span><br><span class="line">    //外部可以通过协议发送执行参数Invocation，然后交给本地Invoker来执行</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line"></span><br><span class="line">    //这个是针对服务消费端的，服务消费者从注册中心获取服务提供者发布的服务信息</span><br><span class="line">    //通过服务信息得知服务提供者使用的协议，然后服务消费者仍然使用该协议构造一个Invoker。这个Invoker是远程通信类的Invoker。</span><br><span class="line">    //执行时，需要将执行信息通过指定协议发送给服务提供者，服务提供者接收到参数Invocation，然后交给服务提供者的本地Invoker来执行</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">    void destroy();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于RegistryProtocol和DubboProtocol的疑惑"><a href="#关于RegistryProtocol和DubboProtocol的疑惑" class="headerlink" title="关于RegistryProtocol和DubboProtocol的疑惑"></a>关于RegistryProtocol和DubboProtocol的疑惑</h3><p>以下是官方文档说明：</p>
<blockquote>
<p>暴露服务:</p>
<p> (1) 只暴露服务端口：</p>
<p>在没有注册中心，直接暴露提供者的情况下，即：<br><code>&lt;dubbo:service regisrty=&quot;N/A&quot; /&gt; or &lt;dubbo:registry address=&quot;N/A&quot; /&gt;</code></p>
<p>ServiceConfig解析出的URL的格式为：<br><code>dubbo://service-host/com.foo.FooService?version=1.0.0</code></p>
<p>基于扩展点的Adaptive机制，通过URL的”dubbo://“协议头识别，直接调用DubboProtocol的export()方法，打开服务端口。</p>
<p> (2) 向注册中心暴露服务：</p>
<p>在有注册中心，需要注册提供者地址的情况下，即：<br><code>&lt;dubbo:registry address=&quot;zookeeper://10.20.153.10:2181&quot; /&gt;</code></p>
<p>ServiceConfig解析出的URL的格式为：<br><code>registry://registry-host/com.alibaba.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)</code></p>
<p>基于扩展点的Adaptive机制，通过URL的”registry://“协议头识别，就会调用RegistryProtocol的export()方法，将export参数中的提供者URL，先注册到注册中心，再重新传给Protocol扩展点进行暴露：<br><code>dubbo://service-host/com.foo.FooService?version=1.0.0</code></p>
<p>基于扩展点的Adaptive机制，通过提供者URL的”dubbo://“协议头识别，就会调用DubboProtocol的export()方法，打开服务端口。</p>
</blockquote>
<p>RegistryProtocol，注册中心协议集成，装饰真正暴露引用服务的协议，增强注册发布功能。</p>
<p>ServiceConfig中的protocol是被多层装饰的Protocol，是DubboProtocol+RegistryProtocol+ProtocolListenerWrapper+ProtocolFilterWrapper。</p>
<ul>
<li>ProtocolFilterWrapper负责初始化invoker所有的Filter。</li>
<li>ProtocolListenerWrapper负责初始化暴露或引用服务的监听器。</li>
<li>RegistryProtocol负责注册服务到注册中心和向注册中心订阅服务。</li>
<li>DubboProtocol负责服务的具体暴露与引用，也负责网络传输层，信息交换层的初始化，以及底层NIO框架的初始化。</li>
</ul>
<h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h2><p>负责invoker的生命周期，包含一个Invoker对象，可以撤销服务。</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>负责数据交换和网络通信的组件。每个Invoker都维护了一个ExchangeClient的 引用，并通过它和远端server进行通信。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.jpg" alt="dachengxi WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="dachengxi Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/dubbo源码/" rel="tag"># dubbo源码</a>
          
            <a href="/tags/dubbo服务暴露/" rel="tag"># dubbo服务暴露</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/18/Dubbo中SPI扩展机制详解/" rel="next" title="Dubbo中SPI扩展机制详解">
                <i class="fa fa-chevron-left"></i> Dubbo中SPI扩展机制详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/19/Netty3服务端流程简介/" rel="prev" title="Netty3服务端流程简介">
                Netty3服务端流程简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="dachengxi" />
          <p class="site-author-name" itemprop="name">dachengxi</p>
           
              <p class="site-description motion-element" itemprop="description">一个小学生</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">84</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">102</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/dachengxi" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/dachengxi" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://git.oschina.net/dachengxi" target="_blank" title="码云">
                  
                    <i class="fa fa-fw fa-git"></i>
                  
                  码云
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友链
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://hexo.io" title="Hexo" target="_blank">Hexo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/iissnan/hexo-theme-next" title="Next Theme" target="_blank">Next Theme</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简易的暴露流程"><span class="nav-number">1.</span> <span class="nav-text">简易的暴露流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring容器初始化调用"><span class="nav-number">2.</span> <span class="nav-text">Spring容器初始化调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ServiceConfig的export"><span class="nav-number">3.</span> <span class="nav-text">ServiceConfig的export</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#export的步骤简介"><span class="nav-number">3.1.</span> <span class="nav-text">export的步骤简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地暴露"><span class="nav-number">3.1.1.</span> <span class="nav-text">本地暴露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#暴露为远程服务"><span class="nav-number">3.1.2.</span> <span class="nav-text">暴露为远程服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#暴露远程服务时的获取Invoker过程"><span class="nav-number">4.</span> <span class="nav-text">暴露远程服务时的获取Invoker过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JavassistProxyFactory获取Invoker"><span class="nav-number">4.1.</span> <span class="nav-text">使用JavassistProxyFactory获取Invoker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JdkProxyFactory获取invoker"><span class="nav-number">4.2.</span> <span class="nav-text">使用JdkProxyFactory获取invoker</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#暴露远程服务时导出Invoker为Exporter"><span class="nav-number">5.</span> <span class="nav-text">暴露远程服务时导出Invoker为Exporter</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Registry类型的Invoker处理过程"><span class="nav-number">5.1.</span> <span class="nav-text">Registry类型的Invoker处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交给具体的协议去暴露服务"><span class="nav-number">5.1.1.</span> <span class="nav-text">交给具体的协议去暴露服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接注册中心并获取Registry实例"><span class="nav-number">5.1.2.</span> <span class="nav-text">连接注册中心并获取Registry实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取Registry时的订阅"><span class="nav-number">5.1.3.</span> <span class="nav-text">获取Registry时的订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取注册到注册中心的url"><span class="nav-number">5.1.4.</span> <span class="nav-text">获取注册到注册中心的url</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册到注册中心"><span class="nav-number">5.1.5.</span> <span class="nav-text">注册到注册中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅注册中心的服务"><span class="nav-number">5.1.6.</span> <span class="nav-text">订阅注册中心的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回新Exporter实例"><span class="nav-number">5.1.7.</span> <span class="nav-text">返回新Exporter实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交给具体的协议进行服务暴露"><span class="nav-number">5.2.</span> <span class="nav-text">交给具体的协议进行服务暴露</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用dubbo协议导出"><span class="nav-number">5.2.1.</span> <span class="nav-text">使用dubbo协议导出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#名词解释"><span class="nav-number">6.</span> <span class="nav-text">名词解释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Invoker"><span class="nav-number">6.1.</span> <span class="nav-text">Invoker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProxyFactory"><span class="nav-number">6.2.</span> <span class="nav-text">ProxyFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protocol"><span class="nav-number">6.3.</span> <span class="nav-text">Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于RegistryProtocol和DubboProtocol的疑惑"><span class="nav-number">6.3.1.</span> <span class="nav-text">关于RegistryProtocol和DubboProtocol的疑惑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exporter"><span class="nav-number">6.4.</span> <span class="nav-text">Exporter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchanger"><span class="nav-number">6.5.</span> <span class="nav-text">Exchanger</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dachengxi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'cxis';
      var disqus_identifier = '2017/02/19/Dubbo中暴露服务的过程解析/';

      var disqus_title = "Dubbo中暴露服务的过程解析";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  










  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


  
<a href="https://github.com/dachengxi"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
