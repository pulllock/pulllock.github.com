<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dachengxi.github.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay&#x3D;”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay&#x3D;”-1”）：  设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo中暴露服务的过程解析">
<meta property="og:url" content="http://dachengxi.github.com/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="大程熙">
<meta property="og:description" content="dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay&#x3D;”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay&#x3D;”-1”）：  设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-02-18T16:46:14.000Z">
<meta property="article:modified_time" content="2017-04-23T04:24:01.000Z">
<meta property="article:author" content="dachengxi">
<meta property="article:tag" content="dubbo源码">
<meta property="article:tag" content="dubbo服务暴露">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dachengxi.github.com/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dubbo中暴露服务的过程解析 | 大程熙</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">大程熙</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">小角落</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book/" rel="section"><i class="fa fa-fw fa-question-circle"></i>读书</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dachengxi.github.com/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="dachengxi">
      <meta itemprop="description" content="一个小学生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大程熙">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dubbo中暴露服务的过程解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-19 00:46:14 00:46:14" itemprop="dateCreated datePublished" datetime="2017-02-19T00:46:14+08:00">2017-02-19 00:46:14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-04-23 12:24:01 12:24:01" itemprop="dateModified" datetime="2017-04-23T12:24:01+08:00">2017-04-23 12:24:01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/02/19/Dubbo中暴露服务的过程解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=”5000”），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=”-1”）：</p>
<ul>
<li>设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。</li>
<li>没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务。</li>
</ul>
<p>但是不管延迟与否，都是使用ServiceConfig的export()方法进行服务的暴露。使用export初始化的时候会将Bean对象转换成URL格式，所有Bean属性转换成URL的参数。</p>
<a id="more"></a>
<p>以没有设置延迟暴露熟属性的过程为例。</p>
<h1 id="简易的暴露流程"><a href="#简易的暴露流程" class="headerlink" title="简易的暴露流程"></a>简易的暴露流程</h1><ol>
<li>首先将服务的实现封装成一个Invoker，Invoker中封装了服务的实现类。</li>
<li>将Invoker封装成Exporter，并缓存起来，缓存里使用Invoker的url作为key。</li>
<li>服务端Server启动，监听端口。（请求来到时，根据请求信息生成key，到缓存查找Exporter，就找到了Invoker，就可以完成调用。）</li>
</ol>
<h1 id="Spring容器初始化调用"><a href="#Spring容器初始化调用" class="headerlink" title="Spring容器初始化调用"></a>Spring容器初始化调用</h1><p>当Spring容器实例化bean完成，走到最后一步发布ContextRefreshEvent事件的时候，ServiceBean会执行onApplicationEvent方法，该方法调用ServiceConfig的export方法。</p>
<p>ServiceConfig初始化的时候，会先初始化静态变量protocol和proxyFactory，这两个变量初始化的结果是通过dubbo的spi扩展机制得到的。</p>
<p>生成的protocol实例是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.alibaba.dubbo.rpc;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line">public class Protocol$Adpative implements com.alibaba.dubbo.rpc.Protocol &#123;</span><br><span class="line">    public com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws java.lang.Class &#123;</span><br><span class="line">        if (arg1 &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.common.URL url &#x3D; arg1;</span><br><span class="line">        String extName &#x3D; ( url.getProtocol() &#x3D;&#x3D; null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line">        if(extName &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension &#x3D; (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.refer(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.Invoker &#123;</span><br><span class="line">        if (arg0 &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">        if (arg0.getUrl() &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() &#x3D;&#x3D; null&quot;);com.alibaba.dubbo.common.URL url &#x3D; arg0.getUrl();</span><br><span class="line">        &#x2F;&#x2F;根据URL配置信息获取Protocol协议，默认是dubbo</span><br><span class="line">        String extName &#x3D; ( url.getProtocol() &#x3D;&#x3D; null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line">        if(extName &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line">            &#x2F;&#x2F;根据协议名，获取Protocol的实现</span><br><span class="line">            &#x2F;&#x2F;获得Protocol的实现过程中，会对Protocol先进行依赖注入，然后进行Wrapper包装，最后返回被修改过的Protocol</span><br><span class="line">            &#x2F;&#x2F;包装经过了ProtocolFilterWrapper，ProtocolListenerWrapper，RegistryProtocol</span><br><span class="line">        com.alibaba.dubbo.rpc.Protocol extension &#x3D; (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.export(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getDefaultPort() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的proxyFactory实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.alibaba.dubbo.rpc;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class ProxyFactory$Adpative implements com.alibaba.dubbo.rpc.ProxyFactory &#123;</span><br><span class="line">    public com.alibaba.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2) throws java.lang.Object &#123;</span><br><span class="line">        if (arg2 &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.common.URL url &#x3D; arg2;</span><br><span class="line">        String extName &#x3D; url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">        if(extName &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.rpc.ProxyFactory extension &#x3D; (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.Invoker &#123;</span><br><span class="line">        if (arg0 &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">       if (arg0.getUrl() &#x3D;&#x3D; null) </span><br><span class="line">        throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() &#x3D;&#x3D; null&quot;);com.alibaba.dubbo.common.URL url &#x3D; arg0.getUrl();</span><br><span class="line"></span><br><span class="line">        String extName &#x3D; url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">        if(extName &#x3D;&#x3D; null) </span><br><span class="line">            throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.rpc.ProxyFactory extension &#x3D; (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.getProxy(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的代码中可以看到，默认的Protocol实现是dubbo，默认的proxy是javassist。</p>
<h1 id="ServiceConfig的export"><a href="#ServiceConfig的export" class="headerlink" title="ServiceConfig的export"></a>ServiceConfig的export</h1><h2 id="export的步骤简介"><a href="#export的步骤简介" class="headerlink" title="export的步骤简介"></a>export的步骤简介</h2><ol>
<li>首先会检查各种配置信息，填充各种属性，总之就是保证我在开始暴露服务之前，所有的东西都准备好了，并且是正确的。</li>
<li>加载所有的注册中心，因为我们暴露服务需要注册到注册中心中去。</li>
<li>根据配置的所有协议和注册中心url分别进行导出。</li>
<li>进行导出的时候，又是一波属性的获取设置检查等操作。</li>
<li>如果配置的不是remote，则做本地导出。</li>
<li>如果配置的不是local，则暴露为远程服务。</li>
<li>不管是本地还是远程服务暴露，首先都会获取Invoker。</li>
<li>获取完Invoker之后，转换成对外的Exporter，缓存起来。</li>
</ol>
<p>export方法先判断是否需要延迟暴露（这里我们使用的是不延迟暴露），然后执行doExport方法。</p>
<p>doExport方法先执行一系列的检查方法，然后调用doExportUrls方法。检查方法会检测dubbo的配置是否在Spring配置文件中声明，没有的话读取properties文件初始化。</p>
<p>doExportUrls方法先调用loadRegistries获取所有的注册中心url，然后遍历调用doExportUrlsFor1Protocol方法。对于在标签中指定了registry属性的Bean，会在加载BeanDefinition的时候就加载了注册中心。</p>
<p>获取注册中心url，会把注册的信息都放在一个URL对象中，一个URL内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;pid&#x3D;2939&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1488898049284</span><br></pre></td></tr></table></figure>

<p>doExportUrlsFor1Protocol根据不同的协议将服务以URL形式暴露。如果scope配置为none则不暴露，如果服务未配置成remote，则本地暴露exportLocal，如果未配置成local，则注册服务registryProcotol。</p>
<p> 这里的URL是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo:&#x2F;&#x2F;192.168.1.100:20880&#x2F;dubbo.common.hello.service.HelloService?anyhost&#x3D;true&amp;application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;delay&#x3D;5000&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;sayHello&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;pid&#x3D;2939&amp;side&#x3D;provider&amp;timestamp&#x3D;1488898464953</span><br></pre></td></tr></table></figure>
<h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><p>这时候会先做本地暴露，exportLocal(url);：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void exportLocal(URL url) &#123;</span><br><span class="line">    if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">    	&#x2F;&#x2F;这时候转成本地暴露的url：injvm:&#x2F;&#x2F;127.0.0.1&#x2F;dubbo.common.hello.service.HelloService?anyhost&#x3D;true&amp;</span><br><span class="line">        &#x2F;&#x2F;application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;</span><br><span class="line">        &#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;sayHello&amp;</span><br><span class="line">        &#x2F;&#x2F;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;pid&#x3D;720&amp;side&#x3D;provider&amp;timestamp&#x3D;1489716708276</span><br><span class="line">        URL local &#x3D; URL.valueOf(url.toFullString())</span><br><span class="line">                .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                .setHost(NetUtils.LOCALHOST)</span><br><span class="line">                .setPort(0);</span><br><span class="line">        &#x2F;&#x2F;首先还是先获得Invoker</span><br><span class="line">        &#x2F;&#x2F;然后导出成Exporter，并缓存</span><br><span class="line">        &#x2F;&#x2F;这里的proxyFactory实际是JavassistProxyFactory</span><br><span class="line">        &#x2F;&#x2F;有关详细的获得Invoke以及exporter会在下面的流程解析，在本地暴露这个流程就不再说明。</span><br><span class="line">        Exporter&lt;?&gt; exporter &#x3D; protocol.export(</span><br><span class="line">                proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">        logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() +&quot; to local registry&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="暴露为远程服务"><a href="#暴露为远程服务" class="headerlink" title="暴露为远程服务"></a>暴露为远程服务</h3><p>接下来是暴露为远程服务，跟本地暴露的流程一样还是先获取Invoker，然后导出成Exporter：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据服务具体实现，实现接口，以及registryUrl通过ProxyFactory将HelloServiceImpl封装成一个本地执行的Invoker</span><br><span class="line">&#x2F;&#x2F;invoker是对具体实现的一种代理。</span><br><span class="line">&#x2F;&#x2F;这里proxyFactory是上面列出的生成的代码</span><br><span class="line"> Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"> &#x2F;&#x2F;使用Protocol将invoker导出成一个Exporter</span><br><span class="line"> &#x2F;&#x2F;暴露封装服务invoker</span><br><span class="line"> &#x2F;&#x2F;调用Protocol生成的适配类的export方法</span><br><span class="line"> &#x2F;&#x2F;这里的protocol是上面列出的生成的代码</span><br><span class="line"> Exporter&lt;?&gt; exporter &#x3D; protocol.export(invoker);</span><br></pre></td></tr></table></figure>
<p><strong>关于Invoker，Exporter等的解释参见最下面的内容。</strong></p>
<h1 id="暴露远程服务时的获取Invoker过程"><a href="#暴露远程服务时的获取Invoker过程" class="headerlink" title="暴露远程服务时的获取Invoker过程"></a>暴露远程服务时的获取Invoker过程</h1><p>服务实现类转换成Invoker，大概的步骤是：</p>
<ol>
<li>根据上面生成的proxyFactory方法调用具体的ProxyFactory实现类的getInvoker方法获取Invoker。</li>
<li>getInvoker的过程是，首先对实现类做一个包装，生成一个包装后的类。</li>
<li>然后新创建一个Invoker实例，这个Invoker中包含着生成的Wrapper类，Wrapper类中有具体的实现类。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure>
<p>这行代码中包含服务实现类转换成Invoker的过程，其中proxyFactory是上面列出的动态生成的代码，其中getInvoker的代码为（做了精简，把包都去掉了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Invoker getInvoker(Object arg0, Class arg1, URL arg2) throws Object &#123;</span><br><span class="line">    if (arg2 &#x3D;&#x3D; null)  throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">	&#x2F;&#x2F;传进来的url是dubbo:&#x2F;&#x2F;192.168.110.197:20880&#x2F;dubbo.common.hello.service.HelloService?anyhost&#x3D;true&amp;application&#x3D;dubbo-provider</span><br><span class="line">    &#x2F;&#x2F;&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;sayHello&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi</span><br><span class="line">    &#x2F;&#x2F;&amp;pid&#x3D;28191&amp;side&#x3D;provider&amp;timestamp&#x3D;1489027396094</span><br><span class="line">    URL url &#x3D; arg2;</span><br><span class="line">    &#x2F;&#x2F;没有proxy参数配置，默认使用javassist</span><br><span class="line">    String extName &#x3D; url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">    if(extName &#x3D;&#x3D; null)  throw new IllegalStateException(&quot;Fail to get extension(ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line">	&#x2F;&#x2F;这一步就使用javassist来获取ProxyFactory的实现类JavassistProxyFactory</span><br><span class="line">    ProxyFactory extension &#x3D; (ProxyFactory)ExtensionLoader.getExtensionLoader(ProxyFactory.class).getExtension(extName);</span><br><span class="line">	&#x2F;&#x2F;JavassistProxyFactory的getInvoker方法</span><br><span class="line">    return extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用JavassistProxyFactory获取Invoker"><a href="#使用JavassistProxyFactory获取Invoker" class="headerlink" title="使用JavassistProxyFactory获取Invoker"></a>使用JavassistProxyFactory获取Invoker</h2><p>JavassistProxyFactory的getInvoker方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">    &#x2F;&#x2F;第一步封装一个Wrapper类</span><br><span class="line">    &#x2F;&#x2F;该类是手动生成的</span><br><span class="line">    &#x2F;&#x2F;如果类是以$开头，就使用接口类型获取，其他的使用实现类获取</span><br><span class="line">    final Wrapper wrapper &#x3D; Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">    &#x2F;&#x2F;返回一个Invoker实例，doInvoke方法中直接返回上面wrapper的invokeMethod</span><br><span class="line">    &#x2F;&#x2F;关于生成的wrapper，请看下面列出的生成的代码，其中invokeMethod方法中就有实现类对实际方法的调用</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成wrapper类的过程，首先看getWrapper方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static Wrapper getWrapper(Class&lt;?&gt; c)&#123;</span><br><span class="line">    while( ClassGenerator.isDynamicClass(c) ) &#x2F;&#x2F; can not wrapper on dynamic class.</span><br><span class="line">        c &#x3D; c.getSuperclass();</span><br><span class="line">	&#x2F;&#x2F;Object类型的</span><br><span class="line">    if( c &#x3D;&#x3D; Object.class )</span><br><span class="line">        return OBJECT_WRAPPER;</span><br><span class="line">	&#x2F;&#x2F;先去Wrapper缓存中查找</span><br><span class="line">    Wrapper ret &#x3D; WRAPPER_MAP.get(c);</span><br><span class="line">    if( ret &#x3D;&#x3D; null ) &#123;</span><br><span class="line">    	&#x2F;&#x2F;缓存中不存在，生成Wrapper类，放到缓存</span><br><span class="line">        ret &#x3D; makeWrapper(c);</span><br><span class="line">        WRAPPER_MAP.put(c,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makeWrapper方法代码不在列出，太长了。就是生成一个继承自Wrapper的类，最后的结果大概是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper1 extends Wrapper &#123;</span><br><span class="line">    public static String[] pns;</span><br><span class="line">    public static Map pts;</span><br><span class="line">    public static String[] mns; &#x2F;&#x2F; all method name array.</span><br><span class="line">    public static String[] dmns;</span><br><span class="line">    public static Class[] mts0;</span><br><span class="line"></span><br><span class="line">    public String[] getPropertyNames() &#123;</span><br><span class="line">        return pns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasProperty(String n) &#123;</span><br><span class="line">        return pts.containsKey($1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class getPropertyType(String n) &#123;</span><br><span class="line">        return (Class) pts.get($1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getMethodNames() &#123;</span><br><span class="line">        return mns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getDeclaredMethodNames() &#123;</span><br><span class="line">        return dmns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPropertyValue(Object o, String n, Object v) &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w &#x3D; ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getPropertyValue(Object o, String n) &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w &#x3D; ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w &#x3D; ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (&quot;sayHello&quot;.equals($2) &amp;&amp; $3.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                w.sayHello();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot; + $2 + &quot;\&quot; in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成完Wrapper以后，返回一个AbstractProxyInvoker实例。至此生成Invoker的步骤就完成了。可以看到Invoker执行方法的时候，会调用Wrapper的invokeMethod，这个方法中会有真实的实现类调用真实方法的代码。</p>
<h2 id="使用JdkProxyFactory获取invoker"><a href="#使用JdkProxyFactory获取invoker" class="headerlink" title="使用JdkProxyFactory获取invoker"></a>使用JdkProxyFactory获取invoker</h2><p>JdkProxyFactory的getInvoker方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            Method method &#x3D; proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">            return method.invoke(proxy, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回一个AbstractProxyInvoker实例，没有做处理，只是使用反射调用具体的方法。</p>
<p>JdkProxyFactory的getProxy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Java的反射机制生成一个代理类。</p>
<h1 id="暴露远程服务时导出Invoker为Exporter"><a href="#暴露远程服务时导出Invoker为Exporter" class="headerlink" title="暴露远程服务时导出Invoker为Exporter"></a>暴露远程服务时导出Invoker为Exporter</h1><p>Invoker导出为Exporter分为两种情况，第一种是Registry类型的Invoker，第二种是其他协议类型的Invoker，分开解析。</p>
<p>代码入口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter &#x3D; protocol.export(invoker);</span><br></pre></td></tr></table></figure>

<h2 id="Registry类型的Invoker处理过程"><a href="#Registry类型的Invoker处理过程" class="headerlink" title="Registry类型的Invoker处理过程"></a>Registry类型的Invoker处理过程</h2><p>大概的步骤是：</p>
<ol>
<li>经过两个不用做任何处理的Wrapper类，然后到达RegistryProtocol中。</li>
<li>通过具体的协议导出Invoker为Exporter。</li>
<li>注册服务到注册中心。</li>
<li>订阅注册中心的服务。</li>
<li>生成一个新的Exporter实例，将上面的Exporter进行引入，然后返回。</li>
</ol>
<p>protocol是上面列出的动态生成的代码，会先调用ProtocolListenerWrapper，这个Wrapper负责初始化暴露和引用服务的监听器。对于Registry类型的不做处理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	&#x2F;&#x2F;registry类型的Invoker，不需要做处理</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;非Registry类型的Invoker，需要被监听器包装</span><br><span class="line">    return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), </span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用ProtocolFilterWrapper中的export方法，ProtocolFilterWrapper负责初始化invoker所有的Filter。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	&#x2F;&#x2F;Registry类型的Invoker不做处理</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;非Registry类型的Invoker需要先构建调用链，然后再导出</span><br><span class="line">    return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先解析的是Registry类型的Invoker，接着就会调用RegistryProtocol的export方法，RegistryProtocol负责注册服务到注册中心和向注册中心订阅服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;</span><br><span class="line">    &#x2F;&#x2F;export invoker</span><br><span class="line">    &#x2F;&#x2F;这里就交给了具体的协议去暴露服务（先不解析，留在后面，可以先去后面看下导出过程）</span><br><span class="line">    final ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; doLocalExport(originInvoker);</span><br><span class="line">    &#x2F;&#x2F;registry provider</span><br><span class="line">    &#x2F;&#x2F;根据invoker中的url获取Registry实例</span><br><span class="line">    &#x2F;&#x2F;并且连接到注册中心</span><br><span class="line">    &#x2F;&#x2F;此时提供者作为消费者引用注册中心核心服务RegistryService</span><br><span class="line">    final Registry registry &#x3D; getRegistry(originInvoker);</span><br><span class="line">    &#x2F;&#x2F;注册到注册中心的URL</span><br><span class="line">    final URL registedProviderUrl &#x3D; getRegistedProviderUrl(originInvoker);</span><br><span class="line">    &#x2F;&#x2F;调用远端注册中心的register方法进行服务注册</span><br><span class="line">    &#x2F;&#x2F;若有消费者订阅此服务，则推送消息让消费者引用此服务。</span><br><span class="line">    &#x2F;&#x2F;注册中心缓存了所有提供者注册的服务以供消费者发现。</span><br><span class="line">    registry.register(registedProviderUrl);</span><br><span class="line">    &#x2F;&#x2F; 订阅override数据</span><br><span class="line">    &#x2F;&#x2F; FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span><br><span class="line">    final URL overrideSubscribeUrl &#x3D; getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    final OverrideListener overrideSubscribeListener &#x3D; new OverrideListener(overrideSubscribeUrl);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    &#x2F;&#x2F;提供者向注册中心订阅所有注册服务的覆盖配置</span><br><span class="line">    &#x2F;&#x2F;当注册中心有此服务的覆盖配置注册进来时，推送消息给提供者，重新暴露服务，这由管理页面完成。</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    &#x2F;&#x2F;保证每次export都返回一个新的exporter实例</span><br><span class="line">    &#x2F;&#x2F;返回暴露后的Exporter给上层ServiceConfig进行缓存，便于后期撤销暴露。</span><br><span class="line">    return new Exporter&lt;T&gt;() &#123;</span><br><span class="line">        public Invoker&lt;T&gt; getInvoker() &#123;</span><br><span class="line">            return exporter.getInvoker();</span><br><span class="line">        &#125;</span><br><span class="line">        public void unexport() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                exporter.unexport();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                registry.unregister(registedProviderUrl);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                overrideListeners.remove(overrideSubscribeUrl);</span><br><span class="line">                registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交给具体的协议去暴露服务"><a href="#交给具体的协议去暴露服务" class="headerlink" title="交给具体的协议去暴露服务"></a>交给具体的协议去暴露服务</h3><p>先不解析，留在后面，可以先去后面看下导出过程，然后再回来接着看注册到注册中心的过程。具体协议暴露服务主要是打开服务器和端口，进行监听。</p>
<h3 id="连接注册中心并获取Registry实例"><a href="#连接注册中心并获取Registry实例" class="headerlink" title="连接注册中心并获取Registry实例"></a>连接注册中心并获取Registry实例</h3><p>具体的协议进行暴露并且返回了一个ExporterChangeableWrapper之后，接下来看下一步连接注册中心并注册到注册中心，代码是在RegistryProtocol的export方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先假装此步已经分析完</span><br><span class="line">final ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; doLocalExport(originInvoker);</span><br><span class="line">&#x2F;&#x2F;得到具体的注册中心，连接注册中心，此时提供者作为消费者引用注册中心核心服务RegistryService</span><br><span class="line">final Registry registry &#x3D; getRegistry(originInvoker);</span><br><span class="line">final URL registedProviderUrl &#x3D; getRegistedProviderUrl(originInvoker);</span><br><span class="line">&#x2F;&#x2F;调用远端注册中心的register方法进行服务注册</span><br><span class="line">&#x2F;&#x2F;若有消费者订阅此服务，则推送消息让消费者引用此服务</span><br><span class="line">registry.register(registedProviderUrl);</span><br><span class="line">&#x2F;&#x2F;提供者向注册中心订阅所有注册服务的覆盖配置</span><br><span class="line">registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">&#x2F;&#x2F;返回暴露后的Exporter给上层ServiceConfig进行缓存</span><br><span class="line">return new Exporter&lt;T&gt;() &#123;。。。&#125;</span><br></pre></td></tr></table></figure>

<p>getRegistry(originInvoker)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据invoker的地址获取registry实例</span><br><span class="line">private Registry getRegistry(final Invoker&lt;?&gt; originInvoker)&#123;</span><br><span class="line">	&#x2F;&#x2F;获取invoker中的registryUrl</span><br><span class="line">    URL registryUrl &#x3D; originInvoker.getUrl();</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(registryUrl.getProtocol())) &#123;</span><br><span class="line">    	&#x2F;&#x2F;获取registry的值，这里获得是zookeeper，默认值是dubbo</span><br><span class="line">        String protocol &#x3D; registryUrl.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_DIRECTORY);</span><br><span class="line">        &#x2F;&#x2F;这里获取到的url为：</span><br><span class="line">        &#x2F;&#x2F;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">        &#x2F;&#x2F;application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;</span><br><span class="line">        &#x2F;&#x2F;environment&#x3D;product&amp;export&#x3D;dubbo%3A%2F%2F192.168.1.100%3A20880%2F</span><br><span class="line">        &#x2F;&#x2F;dubbo.common.hello.service.HelloService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">        &#x2F;&#x2F;application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26</span><br><span class="line">        &#x2F;&#x2F;interface%3Ddubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">        &#x2F;&#x2F;organization%3Dchina%26owner%3Dcheng.xi%26pid%3D9457%26side%3Dprovider%26timestamp%3D1489807681627&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;</span><br><span class="line">        &#x2F;&#x2F;pid&#x3D;9457&amp;timestamp&#x3D;1489807680193</span><br><span class="line">        registryUrl &#x3D; registryUrl.setProtocol(protocol).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;根据SPI机制获取具体的Registry实例，这里获取到的是ZookeeperRegistry</span><br><span class="line">    return registryFactory.getRegistry(registryUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的registryFactory是动态生成的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class RegistryFactory$Adpative implements com.alibaba.dubbo.registry.RegistryFactory &#123;</span><br><span class="line">    public com.alibaba.dubbo.registry.Registry getRegistry(com.alibaba.dubbo.common.URL arg0) &#123;</span><br><span class="line">    </span><br><span class="line">        if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.common.URL url &#x3D; arg0;</span><br><span class="line">        String extName &#x3D; ( url.getProtocol() &#x3D;&#x3D; null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">        if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line"></span><br><span class="line">        com.alibaba.dubbo.registry.RegistryFactory extension &#x3D; (com.alibaba.dubbo.registry.RegistryFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class="line"></span><br><span class="line">        return extension.getRegistry(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里registryFactory.getRegistry(registryUrl)用的是ZookeeperRegistryFactory。</p>
<p>先看下getRegistry方法，会发现该方法会在AbstractRegistryFactory中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public Registry getRegistry(URL url) &#123;</span><br><span class="line">    url &#x3D; url.setPath(RegistryService.class.getName())</span><br><span class="line">            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">    &#x2F;&#x2F;这里key为：</span><br><span class="line">    &#x2F;&#x2F;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService</span><br><span class="line">    String key &#x3D; url.toServiceString();</span><br><span class="line">    &#x2F;&#x2F; 锁定注册中心获取过程，保证注册中心单一实例</span><br><span class="line">    LOCK.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;先从缓存中获取Registry实例</span><br><span class="line">        Registry registry &#x3D; REGISTRIES.get(key);</span><br><span class="line">        if (registry !&#x3D; null) &#123;</span><br><span class="line">            return registry;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建registry，会直接new一个ZookeeperRegistry返回</span><br><span class="line">        &#x2F;&#x2F;具体创建实例是子类来实现的</span><br><span class="line">        registry &#x3D; createRegistry(url);</span><br><span class="line">        if (registry &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can not create registry &quot; + url);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;放到缓存中</span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        return registry;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 释放锁</span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createRegistry(url);是在子类中实现的，这里是ZookeeperRegistry，首先需要经过AbstractRegistry的构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public AbstractRegistry(URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;url保存起来</span><br><span class="line">    setUrl(url);</span><br><span class="line">    &#x2F;&#x2F; 启动文件保存定时器</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    syncSaveFile &#x3D; url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);</span><br><span class="line">    &#x2F;&#x2F;保存的文件为：</span><br><span class="line">    &#x2F;&#x2F;&#x2F;home&#x2F;xxx&#x2F;.dubbo&#x2F;dubbo-registry-127.0.0.1.cache</span><br><span class="line">    String filename &#x3D; url.getParameter(Constants.FILE_KEY, System.getProperty(&quot;user.home&quot;) + &quot;&#x2F;.dubbo&#x2F;dubbo-registry-&quot; + url.getHost() + &quot;.cache&quot;);</span><br><span class="line">    File file &#x3D; null;</span><br><span class="line">    if (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">        file &#x3D; new File(filename);</span><br><span class="line">        if(! file.exists() &amp;&amp; file.getParentFile() !&#x3D; null &amp;&amp; ! file.getParentFile().exists())&#123;</span><br><span class="line">            if(! file.getParentFile().mkdirs())&#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid registry store file &quot; + file + &quot;, cause: Failed to create directory &quot; + file.getParentFile() + &quot;!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.file &#x3D; file;</span><br><span class="line">    &#x2F;&#x2F;加载文件中的属性</span><br><span class="line">    loadProperties();</span><br><span class="line">    &#x2F;&#x2F;通知订阅</span><br><span class="line">    notify(url.getBackupUrls());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取Registry时的订阅"><a href="#获取Registry时的订阅" class="headerlink" title="获取Registry时的订阅"></a>获取Registry时的订阅</h3><p>notify()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    if(urls &#x3D;&#x3D; null || urls.isEmpty()) return;</span><br><span class="line">	&#x2F;&#x2F;getSubscribed()方法获取订阅者列表</span><br><span class="line">    &#x2F;&#x2F;订阅者Entry里每个URL都对应着n个NotifyListener</span><br><span class="line">    for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : getSubscribed().entrySet()) &#123;</span><br><span class="line">        URL url &#x3D; entry.getKey();</span><br><span class="line"></span><br><span class="line">        if(! UrlUtils.isMatch(url, urls.get(0))) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners &#x3D; entry.getValue();</span><br><span class="line">        if (listeners !&#x3D; null) &#123;</span><br><span class="line">            for (NotifyListener listener : listeners) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                	&#x2F;&#x2F;通知每个监听器</span><br><span class="line">                    notify(url, listener, filterEmpty(url, urls));</span><br><span class="line">                &#125; catch (Throwable t) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>notify(url, listener, filterEmpty(url, urls));</code>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; result &#x3D; new HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line">    for (URL u : urls) &#123;</span><br><span class="line">        if (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">        	&#x2F;&#x2F;分类</span><br><span class="line">            String category &#x3D; u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">            List&lt;URL&gt; categoryList &#x3D; result.get(category);</span><br><span class="line">            if (categoryList &#x3D;&#x3D; null) &#123;</span><br><span class="line">                categoryList &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">                result.put(category, categoryList);</span><br><span class="line">            &#125;</span><br><span class="line">            categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified &#x3D; notified.get(url);</span><br><span class="line">    if (categoryNotified &#x3D;&#x3D; null) &#123;</span><br><span class="line">        notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">        categoryNotified &#x3D; notified.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category &#x3D; entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList &#x3D; entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        &#x2F;&#x2F;保存到主目录下的.dubbo目录下</span><br><span class="line">        saveProperties(url);</span><br><span class="line">        &#x2F;&#x2F;上面获取到的监听器进行通知</span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRegistry构造器初始化完，接着调用FailbackRegistry构造器初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public FailbackRegistry(URL url) &#123;</span><br><span class="line">    super(url);</span><br><span class="line">    &#x2F;&#x2F;重试时间，默认5000ms</span><br><span class="line">    int retryPeriod &#x3D; url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line">    &#x2F;&#x2F;启动失败重试定时器</span><br><span class="line">    this.retryFuture &#x3D; retryExecutor.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; 检测并连接注册中心</span><br><span class="line">            try &#123;</span><br><span class="line">            	&#x2F;&#x2F;重试方法由每个具体子类实现</span><br><span class="line">                &#x2F;&#x2F;获取到注册失败的，然后尝试注册</span><br><span class="line">                retry();</span><br><span class="line">            &#125; catch (Throwable t) &#123; &#x2F;&#x2F; 防御性容错&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后回到ZookeeperRegistry的构造初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123;</span><br><span class="line">    super(url);</span><br><span class="line">    if (url.isAnyHost()) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;registry address &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获得到注册中心中的分组，默认dubbo</span><br><span class="line">    String group &#x3D; url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    if (! group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        group &#x3D; Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;注册到注册中心的节点</span><br><span class="line">    this.root &#x3D; group;</span><br><span class="line">    &#x2F;&#x2F;使用zookeeperTansporter去连接</span><br><span class="line">    &#x2F;&#x2F;ZookeeperTransport这里是生成的自适应实现，默认使用ZkClientZookeeperTransporter</span><br><span class="line">    &#x2F;&#x2F;ZkClientZookeeperTransporter的connect去实例化一个ZkClient实例</span><br><span class="line">    &#x2F;&#x2F;并且订阅状态变化的监听器subscribeStateChanges</span><br><span class="line">    &#x2F;&#x2F;然后返回一个ZkClientZookeeperClient实例</span><br><span class="line">    zkClient &#x3D; zookeeperTransporter.connect(url);</span><br><span class="line">    &#x2F;&#x2F;ZkClientZookeeperClient添加状态改变监听器</span><br><span class="line">    zkClient.addStateListener(new StateListener() &#123;</span><br><span class="line">        public void stateChanged(int state) &#123;</span><br><span class="line">            if (state &#x3D;&#x3D; RECONNECTED) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取注册到注册中心的url"><a href="#获取注册到注册中心的url" class="headerlink" title="获取注册到注册中心的url"></a>获取注册到注册中心的url</h3><p>获取到了Registry，Registry实例中保存着连接到了zookeeper的zkClient实例之后，下一步获取要注册到注册中心的url（在RegistryProtocol中）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final URL registedProviderUrl &#x3D; getRegistedProviderUrl(originInvoker);</span><br><span class="line">&#x2F;&#x2F;得到的URL是：</span><br><span class="line">&#x2F;&#x2F;dubbo:&#x2F;&#x2F;192.168.1.100:20880&#x2F;dubbo.common.hello.service.HelloService?</span><br><span class="line">&#x2F;&#x2F;anyhost&#x3D;true&amp;application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;</span><br><span class="line">&#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;sayHello&amp;</span><br><span class="line">&#x2F;&#x2F;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;pid&#x3D;9457&amp;side&#x3D;provider&amp;timestamp&#x3D;1489807681627</span><br></pre></td></tr></table></figure>
<h3 id="注册到注册中心"><a href="#注册到注册中心" class="headerlink" title="注册到注册中心"></a>注册到注册中心</h3><p>然后调用<code>registry.register(registedProviderUrl)</code>注册到注册中心（在RegistryProtocol中）。register方法的实现在FailbackRegistry中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void register(URL url) &#123;</span><br><span class="line">    super.register(url);</span><br><span class="line">    failedRegistered.remove(url);</span><br><span class="line">    failedUnregistered.remove(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 向服务器端发送注册请求</span><br><span class="line">        &#x2F;&#x2F;调用子类具体实现，发送注册请求</span><br><span class="line">        doRegister(url);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Throwable t &#x3D; e;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果开启了启动时检测，则直接抛出异常</span><br><span class="line">        boolean check &#x3D; getUrl().getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; ! Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">        boolean skipFailback &#x3D; t instanceof SkipFailbackWrapperException;</span><br><span class="line">        if (check || skipFailback) &#123;</span><br><span class="line">            if(skipFailback) &#123;</span><br><span class="line">                t &#x3D; t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            throw  。。。</span><br><span class="line">        &#125; else &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将失败的注册请求记录到失败列表，定时重试</span><br><span class="line">        failedRegistered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doRegister(url);</code>在这里是ZookeeperRegistry中具体实现的，这里将会注册到注册中心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegister(URL url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;这里zkClient就是我们上面调用构造的时候生成的</span><br><span class="line">        &#x2F;&#x2F;ZkClientZookeeperClient</span><br><span class="line">        &#x2F;&#x2F;保存着连接到Zookeeper的zkClient实例</span><br><span class="line">        &#x2F;&#x2F;开始注册，也就是在Zookeeper中创建节点</span><br><span class="line">        &#x2F;&#x2F;这里toUrlPath获取到的path为：</span><br><span class="line">        &#x2F;&#x2F;&#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;providers&#x2F;dubbo%3A%2F%2F192.168.1.100%3A20880%2F</span><br><span class="line">        &#x2F;&#x2F;dubbo.common.hello.service.HelloService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">        &#x2F;&#x2F;application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26interface%3D</span><br><span class="line">        &#x2F;&#x2F;dubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">        &#x2F;&#x2F;organization%3Dchina%26owner%3Dcheng.xi%26pid%3D8920%26side%3Dprovider%26timestamp%3D1489828029449</span><br><span class="line">        &#x2F;&#x2F;默认创建的节点是临时节点</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));</span><br><span class="line">    &#125; catch (Throwable e) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过这一步之后，Zookeeper中就有节点存在了，具体节点为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dubbo</span><br><span class="line">	dubbo.common.hello.service.HelloService</span><br><span class="line">    	providers</span><br><span class="line">        	&#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;providers&#x2F;</span><br><span class="line">            dubbo%3A%2F%2F192.168.1.100%3A20880%2Fdubbo.common.hello.service.HelloService%3F</span><br><span class="line">            anyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">            application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26</span><br><span class="line">            interface%3Ddubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">            organization%3Dchina%26owner%3Dcheng.xi%26pid%3D13239%26side%3D</span><br><span class="line">            provider%26timestamp%3D1489829293525</span><br></pre></td></tr></table></figure>

<h3 id="订阅注册中心的服务"><a href="#订阅注册中心的服务" class="headerlink" title="订阅注册中心的服务"></a>订阅注册中心的服务</h3><p>在注册到注册中心之后，registry会去订阅覆盖配置的服务，这一步之后就会在<code>/dubbo/dubbo.common.hello.service/HelloService</code>节点下多一个configurators节点。（具体过程暂先不解析）。</p>
<h3 id="返回新Exporter实例"><a href="#返回新Exporter实例" class="headerlink" title="返回新Exporter实例"></a>返回新Exporter实例</h3><p>最后返回Exporter新实例，返回到ServiceConfig中。服务的发布就算完成了。</p>
<h2 id="交给具体的协议进行服务暴露"><a href="#交给具体的协议进行服务暴露" class="headerlink" title="交给具体的协议进行服务暴露"></a>交给具体的协议进行服务暴露</h2><p>这里也就是非Registry类型的Invoker的导出过程。主要的步骤是将本地ip和20880端口打开，进行监听。最后包装成exporter返回。</p>
<p>doLocalExport(invoker)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt;  doLocalExport(final Invoker&lt;T&gt; originInvoker)&#123;</span><br><span class="line">	&#x2F;&#x2F;原始的invoker中的url：</span><br><span class="line">    &#x2F;&#x2F;registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">    &#x2F;&#x2F;application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3</span><br><span class="line">    &#x2F;&#x2F;&amp;environment&#x3D;product&amp;export&#x3D;dubbo%3A%2F%2F10.42.0.1%3A20880%2F</span><br><span class="line">    &#x2F;&#x2F;dubbo.common.hello.service.HelloService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider%26</span><br><span class="line">    &#x2F;&#x2F;application.version%3D1.0%26dubbo%3D2.5.3%26environment%3Dproduct%26</span><br><span class="line">    &#x2F;&#x2F;interface%3Ddubbo.common.hello.service.HelloService%26methods%3DsayHello%26</span><br><span class="line">    &#x2F;&#x2F;organization%3Dchina%26owner%3Dcheng.xi%26pid%3D7876%26side%3Dprovider%26timestamp%3D1489057305001&amp;</span><br><span class="line">    &#x2F;&#x2F;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;pid&#x3D;7876&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1489057304900</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从原始的invoker中得到的key：</span><br><span class="line">    &#x2F;&#x2F;dubbo:&#x2F;&#x2F;10.42.0.1:20880&#x2F;dubbo.common.hello.service.HelloService?anyhost&#x3D;true&amp;application&#x3D;dubbo-provider&amp;</span><br><span class="line">    &#x2F;&#x2F;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;interface&#x3D;dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">    &#x2F;&#x2F;methods&#x3D;sayHello&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;pid&#x3D;7876&amp;side&#x3D;provider&amp;timestamp&#x3D;1489057305001</span><br><span class="line">    String key &#x3D; getCacheKey(originInvoker);</span><br><span class="line">    ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">    if (exporter &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (bounds) &#123;</span><br><span class="line">            exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">            if (exporter &#x3D;&#x3D; null) &#123;</span><br><span class="line">            	&#x2F;&#x2F;得到一个Invoker代理，里面包含原来的Invoker</span><br><span class="line">                final Invoker&lt;?&gt; invokerDelegete &#x3D; new InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">                &#x2F;&#x2F;此处protocol还是最上面生成的代码，调用代码中的export方法，会根据协议名选择调用具体的实现类</span><br><span class="line">                &#x2F;&#x2F;这里我们需要调用DubboProtocol的export方法</span><br><span class="line">                &#x2F;&#x2F;这里的使用具体协议进行导出的invoker是个代理invoker</span><br><span class="line">                &#x2F;&#x2F;导出完之后，返回一个新的ExporterChangeableWrapper实例</span><br><span class="line">                exporter &#x3D; new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;)protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                bounds.put(key, exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (ExporterChangeableWrapper&lt;T&gt;) exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用dubbo协议导出"><a href="#使用dubbo协议导出" class="headerlink" title="使用dubbo协议导出"></a>使用dubbo协议导出</h3><p>这里<code>protocol.export(invokerDelegete)</code>就要去具体的DubboProtocol中执行了，DubboProtocol的外面包裹着ProtocolFilterWrapper，再外面还包裹着ProtocolListenerWrapper。会先经过ProtocolListenerWrapper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	&#x2F;&#x2F;Registry类型的Invoker</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">   	&#x2F;&#x2F;其他具体协议类型的Invoker</span><br><span class="line">    &#x2F;&#x2F;先进行导出protocol.export(invoker)</span><br><span class="line">    &#x2F;&#x2F;然后获取自适应的监听器</span><br><span class="line">    &#x2F;&#x2F;最后返回的是包装了监听器的Exporter</span><br><span class="line">    &#x2F;&#x2F;这里监听器的获取是getActivateExtension，如果指定了listener就加载实现，没有指定就不加载</span><br><span class="line">    return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker), </span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再经过ProtocolFilterWrapper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	&#x2F;&#x2F;Registry类型的Invoker</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;其他具体协议类型的Invoker</span><br><span class="line">    &#x2F;&#x2F;先构建Filter链，然后再导出</span><br><span class="line">    return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看下构建Invoker链的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123;</span><br><span class="line">	&#x2F;&#x2F;我们要处理的那个Invoker作为处理链的最后一个</span><br><span class="line">    Invoker&lt;T&gt; last &#x3D; invoker;</span><br><span class="line">    &#x2F;&#x2F;根据key和group获取自动激活的Filter</span><br><span class="line">    List&lt;Filter&gt; filters &#x3D; ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    if (filters.size() &gt; 0) &#123;</span><br><span class="line">    	&#x2F;&#x2F;把所有的过滤器都挨个连接起来，最后一个是我们真正的Invoker</span><br><span class="line">        for (int i &#x3D; filters.size() - 1; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">            final Filter filter &#x3D; filters.get(i);</span><br><span class="line">            final Invoker&lt;T&gt; next &#x3D; last;</span><br><span class="line">            last &#x3D; new Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                public Class&lt;T&gt; getInterface() &#123;</span><br><span class="line">                    return invoker.getInterface();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public URL getUrl() &#123;</span><br><span class="line">                    return invoker.getUrl();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public boolean isAvailable() &#123;</span><br><span class="line">                    return invoker.isAvailable();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">                    return filter.invoke(next, invocation);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                public void destroy() &#123;</span><br><span class="line">                    invoker.destroy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public String toString() &#123;</span><br><span class="line">                    return invoker.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就到了DubboProtocol的export方法，这里进行暴露服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">	&#x2F;&#x2F;dubbo:&#x2F;&#x2F;10.42.0.1:20880&#x2F;dubbo.common.hello.service.HelloService?</span><br><span class="line">    &#x2F;&#x2F;anyhost&#x3D;true&amp;application&#x3D;dubbo-provider&amp;</span><br><span class="line">    &#x2F;&#x2F;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;</span><br><span class="line">    &#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">    &#x2F;&#x2F;methods&#x3D;sayHello&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;</span><br><span class="line">    &#x2F;&#x2F;pid&#x3D;7876&amp;side&#x3D;provider&amp;timestamp&#x3D;1489057305001</span><br><span class="line">    URL url &#x3D; invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; export service.</span><br><span class="line">    &#x2F;&#x2F;key由serviceName，port，version，group组成</span><br><span class="line">    &#x2F;&#x2F;当nio客户端发起远程调用时，nio服务端通过此key来决定调用哪个Exporter，也就是执行的Invoker。</span><br><span class="line">    &#x2F;&#x2F;dubbo.common.hello.service.HelloService:20880</span><br><span class="line">    String key &#x3D; serviceKey(url);</span><br><span class="line">    &#x2F;&#x2F;将Invoker转换成Exporter</span><br><span class="line">    &#x2F;&#x2F;直接new一个新实例</span><br><span class="line">    &#x2F;&#x2F;没做啥处理，就是做一些赋值操作</span><br><span class="line">    &#x2F;&#x2F;这里的exporter就包含了invoker</span><br><span class="line">    DubboExporter&lt;T&gt; exporter &#x3D; new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    &#x2F;&#x2F;缓存要暴露的服务，key是上面生成的</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;export an stub service for dispaching event</span><br><span class="line">    &#x2F;&#x2F;是否支持本地存根</span><br><span class="line">    &#x2F;&#x2F;远程服务后，客户端通常只剩下接口，而实现全在服务器端，</span><br><span class="line">    &#x2F;&#x2F;但提供方有些时候想在客户端也执行部分逻辑，比如：做ThreadLocal缓存，</span><br><span class="line">    &#x2F;&#x2F;提前验证参数，调用失败后伪造容错数据等等，此时就需要在API中带上Stub，</span><br><span class="line">    &#x2F;&#x2F;客户端生成Proxy实，会把Proxy通过构造函数传给Stub，</span><br><span class="line">    &#x2F;&#x2F;然后把Stub暴露组给用户，Stub可以决定要不要去调Proxy。</span><br><span class="line">    Boolean isStubSupportEvent &#x3D; url.getParameter(Constants.STUB_EVENT_KEY,Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice &#x3D; url.getParameter(Constants.IS_CALLBACK_SERVICE, false);</span><br><span class="line">    if (isStubSupportEvent &amp;&amp; !isCallbackservice)&#123;</span><br><span class="line">        String stubServiceMethods &#x3D; url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        if (stubServiceMethods &#x3D;&#x3D; null || stubServiceMethods.length() &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;根据URL绑定IP与端口，建立NIO框架的Server</span><br><span class="line">    openServer(url);</span><br><span class="line"></span><br><span class="line">    return exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面得到的Exporter会被放到缓存中去，key就是上面生成的，客户端就可以发请求根据key找到Exporter，然后找到invoker进行调用了。接下来是创建服务器并监听端口。</p>
<p>接着调用openServer方法创建NIO Server进行监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">    &#x2F;&#x2F; find server.</span><br><span class="line">    &#x2F;&#x2F;key是IP:PORT</span><br><span class="line">    &#x2F;&#x2F;192.168.110.197:20880</span><br><span class="line">    String key &#x3D; url.getAddress();</span><br><span class="line">    &#x2F;&#x2F;client 也可以暴露一个只有server可以调用的服务。</span><br><span class="line">    boolean isServer &#x3D; url.getParameter(Constants.IS_SERVER_KEY,true);</span><br><span class="line">    if (isServer) &#123;</span><br><span class="line">    	</span><br><span class="line">        ExchangeServer server &#x3D; serverMap.get(key);</span><br><span class="line">        &#x2F;&#x2F;同一JVM中，同协议的服务，共享同一个Server，</span><br><span class="line">        &#x2F;&#x2F;第一个暴露服务的时候创建server，</span><br><span class="line">        &#x2F;&#x2F;以后相同协议的服务都使用同一个server</span><br><span class="line">        if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">            serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	&#x2F;&#x2F;同协议的服务后来暴露服务的则使用第一次创建的同一Server</span><br><span class="line">            &#x2F;&#x2F;server支持reset,配合override功能使用</span><br><span class="line">            &#x2F;&#x2F;accept、idleTimeout、threads、heartbeat参数的变化会引起Server的属性发生变化</span><br><span class="line">            &#x2F;&#x2F;这时需要重新设置Server</span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看createServer方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;url为：</span><br><span class="line">&#x2F;&#x2F;dubbo:&#x2F;&#x2F;192.168.110.197:20880&#x2F;dubbo.common.hello.service.HelloService?</span><br><span class="line">&#x2F;&#x2F;anyhost&#x3D;true&amp;application&#x3D;dubbo-provider&amp;</span><br><span class="line">&#x2F;&#x2F;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;</span><br><span class="line">&#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">&#x2F;&#x2F;methods&#x3D;sayHello&amp;organization&#x3D;china&amp;owner&#x3D;cheng.xi&amp;</span><br><span class="line">&#x2F;&#x2F;pid&#x3D;720&amp;side&#x3D;provider&amp;timestamp&#x3D;1489716708276</span><br><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认开启server关闭时发送readonly事件</span><br><span class="line">    url &#x3D; url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">    &#x2F;&#x2F;默认开启heartbeat</span><br><span class="line">    url &#x3D; url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">    &#x2F;&#x2F;默认使用netty</span><br><span class="line">    String str &#x3D; url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class="line">        throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);</span><br><span class="line"></span><br><span class="line">    url &#x3D; url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;Exchangers是门面类，里面封装的是Exchanger的逻辑。</span><br><span class="line">        &#x2F;&#x2F;Exchanger默认只有一个实现HeaderExchanger.</span><br><span class="line">        &#x2F;&#x2F;Exchanger负责数据交换和网络通信。</span><br><span class="line">        &#x2F;&#x2F;从Protocol进入Exchanger，标志着程序进入了remote层。</span><br><span class="line">        &#x2F;&#x2F;这里requestHandler是ExchangeHandlerAdapter</span><br><span class="line">        server &#x3D; Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; catch (RemotingException e) &#123; &#125;</span><br><span class="line">    str &#x3D; url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">        Set&lt;String&gt; supportedTypes &#x3D; ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        if (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            throw new RpcException(&quot;Unsupported client type: &quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exchangers.bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">    url &#x3D; url.addParameterIfAbsent(Constants.CODEC_KEY, &quot;exchange&quot;);</span><br><span class="line">    &#x2F;&#x2F;getExchanger方法根据url获取到一个默认的实现HeaderExchanger</span><br><span class="line">    &#x2F;&#x2F;调用HeaderExchanger的bind方法</span><br><span class="line">    return getExchanger(url).bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeaderExchanger的bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">	&#x2F;&#x2F;直接返回一个HeaderExchangeServer</span><br><span class="line">    &#x2F;&#x2F;先创建一个HeaderExchangeHandler</span><br><span class="line">    &#x2F;&#x2F;再创建一个DecodeHandler</span><br><span class="line">    &#x2F;&#x2F;最后调用Transporters.bind</span><br><span class="line">    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会先创建一个HeaderExchangerHandler，包含着ExchangeHandlerAdapter，接着创建一个DecodeHandler，会包含前面的handler，接下来调用Transporters的bind方法，返回一个Server，接着用HeaderExchangeServer包装一下，就返回给Protocol层了。</p>
<p>在HeaderExchangerServer包装的时候会启动心跳定时器<code>startHeatbeatTimer();</code>，暂不解析。</p>
<p>Transports的bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    if (handlers.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        handler &#x3D; handlers[0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	&#x2F;&#x2F;如果有多个handler的话，需要使用分发器包装下</span><br><span class="line">        handler &#x3D; new ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;getTransporter()获取一个Adaptive的Transporter</span><br><span class="line">    &#x2F;&#x2F;然后调用bind方法（默认是NettyTransporter的bind方法）</span><br><span class="line">    return getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getTransporter()生成的Transporter的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Transporter$Adpative implements com.alibaba.dubbo.remoting.Transporter &#123;</span><br><span class="line">    public com.alibaba.dubbo.remoting.Server bind(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1) throws com.alibaba.dubbo.common.URL &#123;</span><br><span class="line">        if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">        com.alibaba.dubbo.common.URL url &#x3D; arg0;</span><br><span class="line">        &#x2F;&#x2F;Server默认使用netty</span><br><span class="line">        String extName &#x3D; url.getParameter(&quot;server&quot;, url.getParameter(&quot;transporter&quot;, &quot;netty&quot;));</span><br><span class="line">        if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(&quot; + url.toString() + &quot;) use keys([server, transporter])&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取到一个NettyTransporter</span><br><span class="line">        com.alibaba.dubbo.remoting.Transporter extension &#x3D; (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</span><br><span class="line">        &#x2F;&#x2F;调用NettyTransporter的bind方法</span><br><span class="line">        return extension.bind(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public com.alibaba.dubbo.remoting.Client connect(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1) throws com.alibaba.dubbo.common.URL &#123;</span><br><span class="line">    if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">    com.alibaba.dubbo.common.URL url &#x3D; arg0;</span><br><span class="line">    </span><br><span class="line">    String extName &#x3D; url.getParameter(&quot;client&quot;, url.getParameter(&quot;transporter&quot;, &quot;netty&quot;));</span><br><span class="line">    </span><br><span class="line">    if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(&quot; + url.toString() + &quot;) use keys([client, transporter])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.remoting.Transporter extension &#x3D; (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.connect(arg0, arg1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyTransporter的bind方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line"> 	&#x2F;&#x2F;创建一个Server</span><br><span class="line">    return new NettyServer(url, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public NettyServer(URL url, ChannelHandler handler) throws RemotingException&#123;</span><br><span class="line">	&#x2F;&#x2F;handler先经过ChannelHandlers的包装方法</span><br><span class="line">    &#x2F;&#x2F;然后再初始化</span><br><span class="line">    super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelHandlers.wrap方法中会根据SPI扩展机制动态生成Dispatcher的自适应类，生成的代码不在列出，默认使用AllDispatcher处理，会返回一个AllChannelHandler，会把线程池和DataStore都初始化了。然后经过HeartbeatHandler封装，再经过MultiMessageHandler封装后返回。</p>
<p>NettyServer构造，会依次经过AbstractPeer，AbstractEndpoint，AbstractServer，NettyServer的初始化。重点看下AbstractServer的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">    super(url, handler);</span><br><span class="line">    localAddress &#x3D; getUrl().toInetSocketAddress();</span><br><span class="line">    String host &#x3D; url.getParameter(Constants.ANYHOST_KEY, false) </span><br><span class="line">                    || NetUtils.isInvalidLocalHost(getUrl().getHost()) </span><br><span class="line">                    ? NetUtils.ANYHOST : getUrl().getHost();</span><br><span class="line">    bindAddress &#x3D; new InetSocketAddress(host, getUrl().getPort());</span><br><span class="line">    this.accepts &#x3D; url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">    this.idleTimeout &#x3D; url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;初始化的时候会打开Server</span><br><span class="line">        &#x2F;&#x2F;具体实现这里是NettyServer中</span><br><span class="line">        doOpen();</span><br><span class="line">    &#125; catch (Throwable t) &#123; &#125;</span><br><span class="line">    if (handler instanceof WrappedChannelHandler )&#123;</span><br><span class="line">        executor &#x3D; ((WrappedChannelHandler)handler).getExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用doOpen方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    &#x2F;&#x2F;boss线程池</span><br><span class="line">    ExecutorService boss &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true));</span><br><span class="line">    &#x2F;&#x2F;worker线程池</span><br><span class="line">    ExecutorService worker &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true));</span><br><span class="line">    &#x2F;&#x2F;ChannelFactory，没有指定工作者线程数量，就使用cpu+1</span><br><span class="line">    ChannelFactory channelFactory &#x3D; new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap &#x3D; new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">    final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);</span><br><span class="line">    channels &#x3D; nettyHandler.getChannels();</span><br><span class="line">    bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">        public ChannelPipeline getPipeline() &#123;</span><br><span class="line">            NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.this);</span><br><span class="line">            ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">            pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">            return pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; bind之后返回一个Channel</span><br><span class="line">    channel &#x3D; bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doOpen方法创建Netty的Server端并打开，具体的事情就交给Netty去处理了，Netty的过程，原理，代码有时间再另行研究。</p>
<ul>
<li>NIO框架接受到消息后，先由NettyCodecAdapter解码，再由NettyHandler处理具体的业务逻辑，再由NettyCodecAdapter编码后发送。</li>
<li>NettyServer既是Server又是Handler。</li>
<li>HeaderExchangerServer只是Server。</li>
<li>MultiMessageHandler是多消息处理Handler。</li>
<li>HeartbeatHandler是处理心跳事件的Handler。</li>
<li>AllChannelHandler是消息派发器，负责将请求放入线程池，并执行请求。</li>
<li>DecodeHandler是编解码Handler。</li>
<li>HeaderExchangerHandler是信息交换Handler，将请求转化成请求响应模式与同步转异步模式。</li>
<li>RequestHandler是最后执行的Handler，会在协议层选择Exporter后选择Invoker，进而执行Filter与Invoker，最终执行请求服务实现类方法。</li>
<li>Channel直接触发事件并执行Handler，Channel在有客户端连接Server的时候触发创建并封装成NettyChannel，再由HeaderExchangerHandler创建HeaderExchangerChannel，负责请求响应模式的处理。</li>
<li>NettyChannel其实是个Handler，HeaderExchangerChannel是个Channel，</li>
<li>消息的序列化与反序列化工作在NettyCodecAdapter中发起完成。</li>
</ul>
<p>当有客户端连接Server时的连接过程：</p>
<ul>
<li>NettyHandler.connected()</li>
<li>NettyServer.connected()</li>
<li>MultiMessageHandler.connected()</li>
<li>HeartbeatHandler.connected()</li>
<li>AllChannelHandler.connected()</li>
<li>DecodeHandler.connected()</li>
<li>HeaderExchangerHandler.connected()</li>
<li>requestHandler.connected()</li>
<li>执行服务的onconnect事件的监听方法</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h2><p>可执行的对象，执行具体的远程调用，能够根据方法名称，参数得到相应的执行结果。</p>
<p>Invocation，包含了需要执行的方法，参数等信息。目前实现类只有RpcInvocation。</p>
<p>有三种类型的Invoker：</p>
<ul>
<li>本地执行类的Invoker。</li>
<li>远程通信执行类的Invoker。</li>
<li>多个远程通信执行类的Invoker聚合成集群版的Invoker。</li>
</ul>
<p>以HelloService为例：</p>
<ul>
<li>本地执行类的Invoker：在Server端有HelloServiceImpl实现，要执行该接口，只需要通过反射执行对应的实现类即可。</li>
<li>远程通信执行类的Invoker：在Client端要想执行该接口的实现方法，需要先进行远程通信，发送要执行的参数信息给Server端，Server端利用本地执行Invoker的方式执行，最后将结果发送给Client。</li>
<li>集群版的Invoker：Client端使用的时候，通过集群版的Invoker操作，Invoker会挑选一个远程通信类型的Invoker来执行。</li>
</ul>
<p>提供者端的Invoker封装了服务实现类，URL，Type，状态都是只读并且线程安全。通过发起invoke来具体调用服务类。</p>
<h2 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h2><p>在服务提供者端，ProxyFactory主要服务的实现统一包装成一个Invoker，Invoker通过反射来执行具体的Service实现对象的方法。默认的实现是JavassistProxyFactory，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">    final Wrapper wrapper &#x3D; Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">    return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object doInvoke(T proxy, String methodName, </span><br><span class="line">                                  Class&lt;?&gt;[] parameterTypes, </span><br><span class="line">                                  Object[] arguments) throws Throwable &#123;</span><br><span class="line">            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>服务地址的发布和订阅。</p>
<p>Protocol是dubbo中的服务域，只在服务启用时加载，无状态，线程安全，是实体域Invoker暴露和引用的主功能入口，负责Invoker的生命周期管理，是Dubbo中远程服务调用层。</p>
<p>Protocol根据指定协议对外公布服务，当客户端根据协议调用这个服务时，Protocol会将客户端传递过来的Invocation参数交给Invoker去执行。</p>
<p>Protocol加入了远程通信协议，会根据客户端的请求来获取参数Invocation。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Extension(&quot;dubbo&quot;)</span><br><span class="line">public interface Protocol &#123;</span><br><span class="line"></span><br><span class="line">    int getDefaultPort();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对于服务提供端，将本地执行类的Invoker通过协议暴漏给外部</span><br><span class="line">    &#x2F;&#x2F;外部可以通过协议发送执行参数Invocation，然后交给本地Invoker来执行</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这个是针对服务消费端的，服务消费者从注册中心获取服务提供者发布的服务信息</span><br><span class="line">    &#x2F;&#x2F;通过服务信息得知服务提供者使用的协议，然后服务消费者仍然使用该协议构造一个Invoker。这个Invoker是远程通信类的Invoker。</span><br><span class="line">    &#x2F;&#x2F;执行时，需要将执行信息通过指定协议发送给服务提供者，服务提供者接收到参数Invocation，然后交给服务提供者的本地Invoker来执行</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">    void destroy();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于RegistryProtocol和DubboProtocol的疑惑"><a href="#关于RegistryProtocol和DubboProtocol的疑惑" class="headerlink" title="关于RegistryProtocol和DubboProtocol的疑惑"></a>关于RegistryProtocol和DubboProtocol的疑惑</h3><p>以下是官方文档说明：</p>
<blockquote>
<p>暴露服务:</p>
<p> (1) 只暴露服务端口：</p>
</blockquote>
<blockquote>
<p>在没有注册中心，直接暴露提供者的情况下，即：<br><code>&lt;dubbo:service regisrty=&quot;N/A&quot; /&gt; or &lt;dubbo:registry address=&quot;N/A&quot; /&gt;</code></p>
</blockquote>
<blockquote>
<p>ServiceConfig解析出的URL的格式为：<br><code>dubbo://service-host/com.foo.FooService?version=1.0.0</code></p>
</blockquote>
<blockquote>
<p>基于扩展点的Adaptive机制，通过URL的”dubbo://“协议头识别，直接调用DubboProtocol的export()方法，打开服务端口。</p>
<p> (2) 向注册中心暴露服务：</p>
</blockquote>
<blockquote>
<p>在有注册中心，需要注册提供者地址的情况下，即：<br><code>&lt;dubbo:registry address=&quot;zookeeper://10.20.153.10:2181&quot; /&gt;</code></p>
</blockquote>
<blockquote>
<p>ServiceConfig解析出的URL的格式为：<br><code>registry://registry-host/com.alibaba.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo://service-host/com.foo.FooService?version=1.0.0&quot;)</code></p>
</blockquote>
<blockquote>
<p>基于扩展点的Adaptive机制，通过URL的”registry://“协议头识别，就会调用RegistryProtocol的export()方法，将export参数中的提供者URL，先注册到注册中心，再重新传给Protocol扩展点进行暴露：<br><code>dubbo://service-host/com.foo.FooService?version=1.0.0</code></p>
</blockquote>
<blockquote>
<p>基于扩展点的Adaptive机制，通过提供者URL的”dubbo://“协议头识别，就会调用DubboProtocol的export()方法，打开服务端口。</p>
</blockquote>
<p>RegistryProtocol，注册中心协议集成，装饰真正暴露引用服务的协议，增强注册发布功能。</p>
<p>ServiceConfig中的protocol是被多层装饰的Protocol，是DubboProtocol+RegistryProtocol+ProtocolListenerWrapper+ProtocolFilterWrapper。</p>
<ul>
<li>ProtocolFilterWrapper负责初始化invoker所有的Filter。</li>
<li>ProtocolListenerWrapper负责初始化暴露或引用服务的监听器。</li>
<li>RegistryProtocol负责注册服务到注册中心和向注册中心订阅服务。</li>
<li>DubboProtocol负责服务的具体暴露与引用，也负责网络传输层，信息交换层的初始化，以及底层NIO框架的初始化。</li>
</ul>
<h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h2><p>负责invoker的生命周期，包含一个Invoker对象，可以撤销服务。</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>负责数据交换和网络通信的组件。每个Invoker都维护了一个ExchangeClient的 引用，并通过它和远端server进行通信。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="dachengxi 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="dachengxi 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/dubbo%E6%BA%90%E7%A0%81/" rel="tag"># dubbo源码</a>
              <a href="/tags/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/" rel="tag"># dubbo服务暴露</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" rel="prev" title="Dubbo中SPI扩展机制详解">
      <i class="fa fa-chevron-left"></i> Dubbo中SPI扩展机制详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/03/19/Netty3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/" rel="next" title="Netty3服务端流程简介">
      Netty3服务端流程简介 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简易的暴露流程"><span class="nav-number">1.</span> <span class="nav-text">简易的暴露流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring容器初始化调用"><span class="nav-number">2.</span> <span class="nav-text">Spring容器初始化调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ServiceConfig的export"><span class="nav-number">3.</span> <span class="nav-text">ServiceConfig的export</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#export的步骤简介"><span class="nav-number">3.1.</span> <span class="nav-text">export的步骤简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本地暴露"><span class="nav-number">3.1.1.</span> <span class="nav-text">本地暴露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#暴露为远程服务"><span class="nav-number">3.1.2.</span> <span class="nav-text">暴露为远程服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#暴露远程服务时的获取Invoker过程"><span class="nav-number">4.</span> <span class="nav-text">暴露远程服务时的获取Invoker过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JavassistProxyFactory获取Invoker"><span class="nav-number">4.1.</span> <span class="nav-text">使用JavassistProxyFactory获取Invoker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JdkProxyFactory获取invoker"><span class="nav-number">4.2.</span> <span class="nav-text">使用JdkProxyFactory获取invoker</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#暴露远程服务时导出Invoker为Exporter"><span class="nav-number">5.</span> <span class="nav-text">暴露远程服务时导出Invoker为Exporter</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Registry类型的Invoker处理过程"><span class="nav-number">5.1.</span> <span class="nav-text">Registry类型的Invoker处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交给具体的协议去暴露服务"><span class="nav-number">5.1.1.</span> <span class="nav-text">交给具体的协议去暴露服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接注册中心并获取Registry实例"><span class="nav-number">5.1.2.</span> <span class="nav-text">连接注册中心并获取Registry实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取Registry时的订阅"><span class="nav-number">5.1.3.</span> <span class="nav-text">获取Registry时的订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取注册到注册中心的url"><span class="nav-number">5.1.4.</span> <span class="nav-text">获取注册到注册中心的url</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册到注册中心"><span class="nav-number">5.1.5.</span> <span class="nav-text">注册到注册中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅注册中心的服务"><span class="nav-number">5.1.6.</span> <span class="nav-text">订阅注册中心的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回新Exporter实例"><span class="nav-number">5.1.7.</span> <span class="nav-text">返回新Exporter实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交给具体的协议进行服务暴露"><span class="nav-number">5.2.</span> <span class="nav-text">交给具体的协议进行服务暴露</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用dubbo协议导出"><span class="nav-number">5.2.1.</span> <span class="nav-text">使用dubbo协议导出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#名词解释"><span class="nav-number">6.</span> <span class="nav-text">名词解释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Invoker"><span class="nav-number">6.1.</span> <span class="nav-text">Invoker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProxyFactory"><span class="nav-number">6.2.</span> <span class="nav-text">ProxyFactory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protocol"><span class="nav-number">6.3.</span> <span class="nav-text">Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于RegistryProtocol和DubboProtocol的疑惑"><span class="nav-number">6.3.1.</span> <span class="nav-text">关于RegistryProtocol和DubboProtocol的疑惑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exporter"><span class="nav-number">6.4.</span> <span class="nav-text">Exporter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchanger"><span class="nav-number">6.5.</span> <span class="nav-text">Exchanger</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dachengxi"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">dachengxi</p>
  <div class="site-description" itemprop="description">一个小学生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">105</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dachengxi" title="GitHub → https://github.com/dachengxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/dachengxi" title="微博 → http://weibo.com/dachengxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>微博</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://git.oschina.net/dachengxi" title="码云 → http://git.oschina.net/dachengxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-git"></i>码云</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://hexo.io" title="http://hexo.io" rel="noopener" target="_blank">Hexo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/iissnan/hexo-theme-next" title="https://github.com/iissnan/hexo-theme-next" rel="noopener" target="_blank">Next Theme</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dachengxi</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://cxis.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://dachengxi.github.com/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/";
    this.page.identifier = "2017/02/19/Dubbo中暴露服务的过程解析/";
    this.page.title = "Dubbo中暴露服务的过程解析";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://cxis.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

  <a href="https://github.com/dachengxi" target="_blank" rel="noopener"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
