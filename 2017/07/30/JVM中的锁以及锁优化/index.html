<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>JVM中的锁以及锁优化</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	

</head>
<body>
	<header>
	=================<br>
	== <a href="https://cxis.me/">Time Stream</a> ==<br>
	=================
	<div style="float: right;">一个小学生</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories"><b>Categories</b></a>.
			
			<a href="/tags"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>JVM中的锁以及锁优化</h1>
			<b><time>2017-07-30 23:50:58</time></b>
		       
		           <a href="/tags/JVM">JVM</a>
        	       

			<div>
				<p>JVM中的锁优化学习。</p>
<p>锁优化包括：自适应自旋、锁消除、锁膨胀、轻量级锁、偏向锁等。</p>
<h1 id="偏向锁">偏向锁</h1>
<p>偏向锁是在无竞争的情况下，取消之前已经取得锁的线程同步操作。当一个锁对象被一个线程获取后，就进入了偏向模式，当同一个线程再次请求这个锁，无需再进行同步操作。</p>
<p>偏向锁工作过程：</p>
<ul>
<li>当一个锁对象第一次被线程获取的时候，JVM会把锁对象头中的锁标志位设置为01，偏向模式设置为1，表示偏向锁模式。同时使用CAS操作把获取到这个锁的线程ID记录到对象头的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入到这个锁相关的同步块时，JVM不再进行任何同步操作。</li>
<li>一旦出现另外一个线程尝试获取这个锁，偏向锁模式就立马结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向模式，撤销后锁标志恢复到未锁定01状态或者轻量级锁00状态，后续操作会按照轻量级锁那样去执行。</li>
</ul>
<p>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</p>
<p>如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。</p>
<h1 id="轻量级锁">轻量级锁</h1>
<p>轻量级锁在无竞争情况下使用CAS去消除同步使用的互斥量。是JDK6加入的新型锁机制。在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。绝大部分的锁，在整个同步周期都是不存在竞争的，轻量级锁通过CAS操作避免了使用互斥量的开销。如果有竞争的话，除了互斥量的开销还有CAS操作开销，轻量级锁就比重量级锁要慢。</p>
<p>轻量级锁工作过程：</p>
<ul>
<li>代码即将进入同步块的时候，如果此同步对象没有被锁定，锁标志位01状态，JVM会首先在当前线程的栈帧中建立一个锁记录空间，用于存储锁对象目前的Mark Word拷贝。</li>
<li>然后JVM使用CAS尝试把对象的Mark Word更新为指向锁记录的指针，如果成功，表示该线程拥有了这个对象的锁，并且对象的Mark Word锁标志位变成00表示轻量级锁。如果操作失败，表示有其他线程竞争这个对象的锁，JVM会先检查对象的Mark Word是否指向当前线程的栈帧，如果是的话，就说明当前已经拥有了这个对象的锁，直接继续同步；否则说明这个锁对象已经被其他线程抢占了。如果出现竞争锁的情况，轻量级锁需要膨胀为重量级锁，锁标志变为10，Mark Word中存储的是指向重量级锁的指针，后面等待锁的线程必须进入阻塞状态。</li>
<li>轻量级锁解锁也是使用CAS，如果对象的Mark Word仍然指向线程的锁记录，就使用CAS把对象的Mark Word和线程锁记录中的Mark Word替换回来，如果能够成功，就完成了；如果替换失败，说明有其他线程尝试获取过该锁，在释放锁的同时，唤醒被挂起的线程。</li>
</ul>
<h1 id="锁膨胀">锁膨胀</h1>
<p>轻量级锁获取锁失败后，JVM会使用重量级锁。锁标志位变成10状态，Mark Word指向monitor对象指针。</p>
<p>重量级锁工作过程：</p>
<ul>
<li>废弃获取轻量级锁的线程栈中备份的对象头信息。</li>
<li>进行锁膨胀获取对象的ObjectMonitor，然后使用enter方法尝试进入该锁。</li>
<li>获取不到锁的线程就会在操作系统层面被挂起。</li>
</ul>
<h1 id="自旋锁与自适应自旋">自旋锁与自适应自旋</h1>
<p>轻量级锁膨胀为重量级锁后，线程可能会在操作系统层面被挂起，线程切换的性能损失很大。JVM会在锁膨胀后会做最后争取，希望线程可以尽快进入临界区而避免被操作系统挂起。一般线程加锁时间都很短，其他线程争取不到锁也不必立刻就进入挂起状态，可以选择忙循环（自旋）来等待锁释放。这种就是自旋锁。</p>
<p>自旋锁在锁的占用时间很短的情况下，自旋等待效果很好，但是如果锁被长时间占有，自旋就只会消耗处理器资源了。所以自旋等待必须有限度，超过了限定的次数还没有获取到锁，就使用传统的方式挂起线程。</p>
<p>如果固定了自旋次数，JVM中所有的锁都会使用这个次数，对不同的锁有可能不太适用。JDK6引入了自适应自旋，也就是自旋的次数不是固定的，而是由前一次在同一个锁上的自选时间以及锁的拥有者的状态来决定。</p>
<ul>
<li>如果在同一个锁对象上，自选等待刚刚成功获取锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也很有可能再次成功，就允许自选等待持续更长时间。</li>
<li>如果对于某个锁，自旋很少能成功获取锁，以后要获取这个锁时可能会直接忽略自旋，避免浪费处理器资源。</li>
</ul>
<h1 id="锁消除">锁消除</h1>
<p>JVM在即时编译器运行时，会对运行上下文扫描，对一些使用到了锁的代码，但是实际运行时根本不需要加锁的代码，可以把锁消除。</p>
<p>比如使用StringBuffer这个类，相关方法都使用synchronized修饰，在实际使用的过程中很可能不会出现竞争，如果还继续加锁的话就会浪费性能，这时候虚拟机可能会将锁进行消除。</p>
<p>锁消除依赖逃逸分析技术。</p>
<h1 id="锁粗化">锁粗化</h1>
<p>JVM检测到有一连串零碎的操作都对同一个对象加锁，就会把锁同步范围粗化到整个操作序列的外部。可以理解为多次连续对同一个对象加锁，但是其实只需要一次加锁就能解决的问题，就可以直接将锁粗化。</p>
<p>比如循环里面出现加锁，如果只在循环体外加一次锁就可以解决，就会进行锁粗化。</p>
<h1 id="jvm中使用锁的过程">JVM中使用锁的过程</h1>
<ul>
<li>一个普通对象，Mark Word中记录对象的哈希码、GC分代年龄，锁标志位为01，偏向锁模式位为0.</li>
<li>当对象被当做同步锁，并且有一个线程抢到了锁，锁标志位还是01，偏向锁模式位为1，前23位记录抢到锁的线程的id，接着是偏向锁时间戳、GC分代年龄，目前是偏向锁模式。</li>
<li>当同一个线程再来获取锁，JVM发现锁对象的处于偏向锁模式，Mark Word中线程id是当前线程，说明当前线程持有锁，可以继续执行同步代码。</li>
<li>当另外一个线程来获取锁，JVM发现所对象处于偏向锁状态，Mark Word中线程id不是当前线程，当前线程会先使用CAS尝试获取锁，有可能获取成功，因为持有偏向锁的线程不会自动释放偏向锁。如果当前线程抢锁成功，就把锁对象的Mark Word的线程改为当前线程的id，当前线程获取到了偏向锁。</li>
<li>如果获取偏向锁抢锁失败，说明锁对象有竞争，偏向锁升级为轻量级锁。JVM会在当前线程的栈帧中创建一个锁记录空间，用来保存锁对象的Mark Word，同时在锁对象的Mark Word中保存指向这个锁记录空间的指针，如果上述操作成功，当前线程抢到了锁，锁标志位修改为00轻量级锁模式，如果失败了，说明有竞争，继续执行下面的步骤。</li>
<li>轻量级锁抢锁失败后，JVM会使用自旋锁，当前线程自旋，如果规定的自旋时间内获取到锁，就说明成功获取锁，执行同步代码块，如果自旋不能成功获取，就会升级为重量级锁。</li>
<li>自旋不能成功获取锁，锁会升级为重量级锁，锁标志位10，锁对象的MarkWord存储指向重量级锁的指针。后面获取锁的线程都会阻塞。</li>
</ul>
<h1 id="锁在应用层的优化">锁在应用层的优化</h1>
<ul>
<li>减少锁持有时间，只在必要时进行同步操作，可以减少线程持有锁的时间，提高系统吞吐量</li>
<li>减小锁粒度，比如ConcurrentHashMap实现，分为多个锁，不同段的数据可以同时操作。但是当系统需要获取全局锁的时候，消耗资源会比较多，比如ConcurrentHashMap要获取size时，需要将所有子段都加锁。</li>
<li>锁分离，比如LinkedBlockingQueue的实现，分成了两个锁takeLock和putLock，实现读写数据的分离。</li>
<li>无锁CAS。</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li>《实战Java虚拟机 JVM故障诊断与性能优化》</li>
<li>《HotSpot实战》</li>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》</li>
</ul>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/2021/02/23/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之直接选择排序学习</a></li>
				
				<li><a href="/2021/02/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%88%90%E5%AF%B9%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之成对插入排序学习</a></li>
				
				<li><a href="/2021/02/18/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之快速排序学习</a></li>
				
				<li><a href="/2021/02/18/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之冒泡排序学习</a></li>
				
				<li><a href="/2021/02/09/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之希尔排序学习</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2021 <a href="https://cxis.me/"><b>cxis</b></a>.
	<a href="https://gohugo.io/"><b>Hugo</b></a>.
	<a href="https://github.com/colorchestra/smol"><b>Smol</b></a>.
	<a href="https://github.com/dachengxi"><b>Github</b></a>.
	</p>
</footer>

</body>
<script>
    window.MathJax = {
    tex: {
      tags: 'ams',  
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-svg.min.js" integrity="sha512-cvY8FLZ100SA0lUHyX38BDEr1rz0AKP6Iz+t5yfOPOyuKX72RNHIuPGH/+ScEsbKBhngYhKJSaFbtKet0te1Sw==" crossorigin="anonymous"></script>
</html>
