<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>JVM中的即时编译</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	

</head>
<body>
	<header>
	=================<br>
	== <a href="https://cxis.me/">Time Stream</a> ==<br>
	=================
	<div style="float: right;">一个小学生</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories"><b>Categories</b></a>.
			
			<a href="/tags"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>JVM中的即时编译</h1>
			<b><time>2017-09-09 09:19:51</time></b>
		       
		           <a href="/tags/JVM">JVM</a>
        	       

			<div>
				<p>JVM中的即时编译学习。</p>
<ul>
<li>解释器：Java源程序编译成字节码后，运行时环境对字节码进行解释执行，提供解释执行的组件就是解释器interpreter。执行方式是一边翻译一边执行，效率低，但是简单易于实现</li>
<li>即时编译器（JIT编译器）：运行时程序执行频繁的代码称为热点代码，JVM使用即时编译器将热点代码编译成本地代码。Hotspot中有客户端编译器（C1编译器）和服务端编译器（C2编译器），C1编译速度快，C2会进行更多优化，C2编译比C1耗时</li>
</ul>
<p>Hotspot提供了三种运行模式：</p>
<ul>
<li>解释模式，<code>-Xint</code>选项指定，JVM使用解释模式运行</li>
<li>编译模式，<code>-Xcomp</code>选项指定，JVM使用编译模式运行</li>
<li>混合模式，<code>-Xmixed</code>选项指定，JVM以解释加编译模式运行，Hotspot默认是混合模式</li>
</ul>
<h1 id="即时编译器">即时编译器</h1>
<p>Hotspot中即时编译器包括客户端（C1）编译器和服务端（C2）编译器，其中C1编译器编译速度快，C2编译器做的优化多耗时多能产生更高效代码。</p>
<ul>
<li>C1编译器简单快速，适用于执行时间较短或者对启动性能有要求的程序，比如GUI应用会对界面启动速度有要求</li>
<li>C2编译器适用于执行时间长或对峰值性能有要求的程序，比如服务器上长期运行的程序对稳定运行有一定的要求</li>
</ul>
<h2 id="分层编译">分层编译</h2>
<p>在Java7之前，需要自己根据需要来选择对应JIT编译器，JVM默认采用解释器和其中一个JIT编译器配合进行工作，在Java7中引入了分层编译，解释器可以和C1、C2编译器协同运行，进行分层编译：</p>
<ul>
<li>第0级，CompLevel_none，采用解释器解释执行，不采集性能监控数据，可升级到第1级</li>
<li>第1级，CompLevel_simple，采用C1编译器，会把热点代码快速编译成本地代码，不开启性能监控</li>
<li>第2级，CompLevel_limited_profile，采用C1编译器，仅开启方法次数统计和回边次数统计等有限的性能监控功能</li>
<li>第3级，CompLevel_full_profile，采用C1编译器，开启全部性能监控，采集性能数据进行优化措施，包括：方法次数统计、回边次数统计、手机分支跳转统计、虚方法调用版本统计信息</li>
<li>第4级，CompLevel_full_optimization，采用C2编译器，进行完全的优化，根据性能监控信息进行一些不可靠的激进优化</li>
</ul>
<p>Java7中可使用<code>-client</code>或者<code>-server</code>强制指定JVM的即时编译器，在Java8中这两个选项取消了，如果想只使用C2，可以关闭分层编译<code>-XX:TieredCompilation</code>，如果只想用C1，可在打开分层编译的同时，使用参数：<code>-XX:TieredStopAtLevel=1</code></p>
<h2 id="编译执行路径">编译执行路径</h2>
<ul>
<li>通常情况下：0 -&gt; 3 -&gt; 4 ，通常情况下热点方法会被3层的C1编译，然后被4层的C2编译</li>
<li>字节码较少的方法：0  -&gt; 3 -&gt; 1，字节码较少的情况下，没有什么可收集的性能数据，会在3层C1编译后，直接交给1层C1来编译</li>
<li>C1繁忙：0 -&gt; 4，C1繁忙时，JVM在解释执行时收集性能数据，然后直接由4层C2编译</li>
<li>C2繁忙：0 -&gt; 2  -&gt; 3 -&gt; 4，C2繁忙时，先由2层C1编译，再由3层C1编译，可减少方法在3层的执行时间，最后交给4层C2执行</li>
</ul>
<h1 id="栈上替换">栈上替换</h1>
<p>热点代码包括：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>被多次调用的方法，依靠方法调用触发编译，编译器会以整个方法作为编译对象。</p>
<p>被多次执行的循环体，热点代码只是方法的一部分，但编译器必须对整个方法作为编译对象，只是执行入口会有不同，编译时会传入执行入口字节码序号，这种在方法执行过程中就进行编译的方式成为栈上替换（On Stack Replacement，OSR）</p>
<h1 id="热点探测">热点探测</h1>
<p>热点探测用来判断某段代码是不是热点代码，是不是需要触发即时编译。有两种判定方式：</p>
<ul>
<li>基于采样的热点探测，周期性检查各个线程栈顶，如果发现某个方法经常出现在栈顶，就可以认为是热点方法。实现简单高效，可以容易获取方法调用关系，但是容易受线程阻塞或别的外界因素的影响而扰乱热点探测</li>
<li>基于计数器的热点探测，JVM会为每个方法建立计数器，统计方法执行次数，如果超过了阈值就可以认为是热点方法，统计更精确，但是实现麻烦，不能直接获取到方法调用关系</li>
</ul>
<p>Hotspot虚拟机采用基于计数器的热点探测方法，有两类计数器：</p>
<ul>
<li>方法调用计数器，用来统计方法被调用次数</li>
<li>回边计数器，用来统计方法中循环体的代码执行次数</li>
</ul>
<h2 id="方法调用计数器">方法调用计数器</h2>
<p>方法调用计数器，用来统计方法被调用的次数。默认设置下并不是统计的方法被调用的绝对次数，而是一个相对次数，即一段时间之内方法被调用次数。当超过一定的时间限度，如果方法的调用次数仍不足触发即时编译，则该方法的调用计数器就会减少一半，这个过程称为方法调用计数器热度衰减，这段时间称为此方法统计的半衰周期。热度衰减是在虚拟机进行垃圾收集时进行的。</p>
<p>可使用<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法调用次数统计变为绝对次数。</p>
<p>当一个方法被调用时，JVM先检查方法是否存在被即时编译器编译过的版本，如果存在则使用编译后的本地代码执行。如果不存在已编译过的版本，则将方法的计数器加1，然后判断计数器和回边计数器值的和是否超过方法调用计数器的阈值，如果超过阈值则向编译器提交一个该方法的代码编译请求。当编译工作完成后，方法调用入口地址就会被改成新的，下次调用该方法时就会使用已编译版本。</p>
<h2 id="回边计数器">回边计数器</h2>
<p>回边计数器用来统计一个方法中循环体的执行次数。用来触发栈上替换编译。</p>
<p>当解释器遇到一条回边指令，先查找将要执行的代码片段是否已有编译好的版本，如果有就优先执行已编译的代码。如果没有就把回边计数器值加1，然后判断方法调用计数器和回边计数器值的和是否超过回边计数器的阈值。如果超过阈值，将会提交一个栈上替换编译请求，并把回边计数器值稍微降低，以便继续在解释器中执行循环。</p>
<h1 id="编译过程">编译过程</h1>
<p>默认条件下，方法调用和栈上替换的编译请求会在后台编译线程中进行，正常的方法调用都会以解释模式继续执行代码。</p>
<p><code>-XX:-BackgroundCompilation</code>选项可以禁止后台编译，当达到触发即时编译的条件时，正在执行的线程会提交编译请求并阻塞等待编译请求完成，然后执行编译后的本地代码。</p>
<h2 id="c1编译过程">C1编译过程</h2>
<ul>
<li>第一个阶段，从字节码到高级中间代码表示（HIR，High Level Intermediate Representation，与目标机器指令集无关的中间表示）。在转换为HIR之前编译器在字节码上完成一部分基础优化：方法内联、常量传播等</li>
<li>第二个阶段，从HIR到低级中间代码表示（LIR，Low Level Intermediate Representation，与目标机器指令集相关的中间表示）。在转换为LIR之前会在HIR基础上完成一些优化：空值检查消除、范围检查消除等</li>
<li>第三个阶段，在平台相关的后台使用线性扫描算法（Linear Scam Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码</li>
</ul>
<h2 id="c2编译过程">C2编译过程</h2>
<h1 id="方法内联">方法内联</h1>
<p>方法内联可以消除方法调用的成本，还是其他优化手段的基础。方法内联是把目标方法的代码复制到发起调用的方法中，避免真实的方法调用。</p>
<p>JVM会自动识别热点代码，并对他们使用方法内联，如果方法体太大，JVM将不执行内联操作：</p>
<ul>
<li>经常执行的方法，默认方法体大小小于325字节，会进行内联</li>
<li>不经常执行的方法，默认方法小于35字节，会进行内联</li>
</ul>
<p>invokespecial指令调用的私有方法、实力构造方法、父类方法和invokestatic调用的静态方法以及final修改的方法，这些方法都是非虚方法。这些方法在编译期进行解析。</p>
<p>除了上述非虚方法外，Java中剩下的都是虚方法，虚方法调用必须在运行时进行方法接收者的多态选择，在编译器静态的做内联的时候很难确定应该使用哪个方法版本。</p>
<h2 id="类型继承关系分析">类型继承关系分析</h2>
<p>JVM使用类型继承关系分析（Class Hierarchy Analysis，CHA）技术来解决虚方法的内联问题。CHA是整个应用程序范围内的类型分析技术，用于在已经加载的类中确定某个接口是否有多个实现、某个类是否有子类、子类是否覆盖了父类的某些虚方法等。</p>
<p>类型继承关系分析后，就可以根据情况进行内联：</p>
<ul>
<li>如果是非虚方法，则直接进行内联</li>
<li>如果是虚方法，需要使用类型继承关系分析该方法在当前状态下是否真的有多个目标版本可供选择</li>
</ul>
<p>CHA分析如果只有一个版本，就可以假设应用后面的状态也和现在的状态一样，可进行内联操作，这种被称为守护内联（Guarded Inlining），守护内联只是根据当前状态来进行假设，如果后续程序执行过程中，虚拟机一直没有加载到会让这个方法的接收者继承关系发生变化的类，这个内联优化的代码就可以一直使用下去；如果加载了导致方法接收者继承关系发生变化的新类，就必须抛弃原来已经编译的代码，退回到解释执行的状态或者重新进行编译。</p>
<p>CHA分析如果该方法有多个版本的目标方法可供选择，即时编译器会使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。</p>
<h1 id="逃逸分析">逃逸分析</h1>
<p>逃逸分析Escape Analysis，不是直接优化代码的手段，而是为了其他优化措施提供依据的分析技术，比如：栈上分配、标量替换、同步消除等都是依赖逃逸分析的。</p>
<p>逃逸分析是分析对象的动态作用域，当对象在方法里面被定义后，如果能被外部方法引用，则称方法逃逸；如果对象能被外部线程访问到，则称线程逃逸。</p>
<ul>
<li>如果一个对象不能被外部方法被访问到，则可以使用栈上分配</li>
<li>如果一个对象不能被外部方法访问到，并且对象可以被拆散，那么程序运行的时候可能不去创建这个对象，而是直接创建对象的若干成员变量来替换，称为标量替换</li>
<li>如果一个变量不会逃逸出线程，无法被其他线程访问到，那么这个变量读写肯定不会有竞争，可以对这个变量实施同步消除</li>
</ul>
<h1 id="公共子表达式消除">公共子表达式消除</h1>
<p>如果一个表达式之前已经被计算过了，并且从先前的计算到现在为止，这个表达式中所有变量值都没有发生变化，那么这个表达式就称为公共子表达式。</p>
<p>公共子表达式不需要重新计算，可以直接使用前面计算过的表达式结果。</p>
<p>如果这种优化仅限于程序块内，可称为局部公共子表达式消除。如果这种优化涵盖了多个基本块，就称为全局公共子表达式消除。</p>
<h1 id="数组边界检查消除">数组边界检查消除</h1>
<p>如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0, array.length)内，再循环中就可以把整个数组的上下边界检查消除掉，可以节省很多次的条件判断操作。</p>
<h1 id="参考">参考</h1>
<ul>
<li>《深入Java虚拟机》</li>
<li>《实战Java虚拟机 JVM故障诊断与性能优化》</li>
<li>《HotSpot实战》</li>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》</li>
<li>《Java虚拟机规范》</li>
<li><a href="https://blog.csdn.net/kuenking111/article/details/90106894">https://blog.csdn.net/kuenking111/article/details/90106894</a></li>
</ul>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/2021/02/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E6%AF%94%E8%BE%83/">算法之各类排序算法总结比较</a></li>
				
				<li><a href="/2021/02/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之归并排序学习</a></li>
				
				<li><a href="/2021/02/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之堆排序学习</a></li>
				
				<li><a href="/2021/02/23/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之直接选择排序学习</a></li>
				
				<li><a href="/2021/02/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%88%90%E5%AF%B9%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之成对插入排序学习</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2021 <a href="https://cxis.me/"><b>cxis</b></a>.
	<a href="https://gohugo.io/"><b>Hugo</b></a>.
	<a href="https://github.com/colorchestra/smol"><b>Smol</b></a>.
	<a href="https://github.com/dachengxi"><b>Github</b></a>.
	</p>
</footer>

</body>
<script>
    window.MathJax = {
    tex: {
      tags: 'ams',  
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-svg.min.js" integrity="sha512-cvY8FLZ100SA0lUHyX38BDEr1rz0AKP6Iz+t5yfOPOyuKX72RNHIuPGH/+ScEsbKBhngYhKJSaFbtKet0te1Sw==" crossorigin="anonymous"></script>
</html>
