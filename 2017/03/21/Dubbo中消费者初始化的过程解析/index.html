<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dachengxi.github.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="首先还是Spring碰到dubbo的标签之后，会使用parseCustomElement解析dubbo标签，使用的解析器是dubbo的DubboBeanDefinitionParser，解析完成之后返回BeanDefinition给Spring管理。 服务消费者端对应的是ReferenceBean，实现了ApplicationContextAware接口，Spring会在Bean的实例化那一步回调">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo中消费者初始化的过程解析">
<meta property="og:url" content="http://dachengxi.github.com/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="大程熙">
<meta property="og:description" content="首先还是Spring碰到dubbo的标签之后，会使用parseCustomElement解析dubbo标签，使用的解析器是dubbo的DubboBeanDefinitionParser，解析完成之后返回BeanDefinition给Spring管理。 服务消费者端对应的是ReferenceBean，实现了ApplicationContextAware接口，Spring会在Bean的实例化那一步回调">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-03-21T12:30:29.000Z">
<meta property="article:modified_time" content="2017-04-23T07:14:08.000Z">
<meta property="article:author" content="dachengxi">
<meta property="article:tag" content="dubbo源码">
<meta property="article:tag" content="dubbo消费者初始化">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://dachengxi.github.com/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Dubbo中消费者初始化的过程解析 | 大程熙</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">大程熙</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">小角落</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>列表</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book/" rel="section"><i class="fa fa-fw fa-question-circle"></i>读书</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dachengxi.github.com/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="dachengxi">
      <meta itemprop="description" content="一个小学生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大程熙">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dubbo中消费者初始化的过程解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-21 20:30:29 20:30:29" itemprop="dateCreated datePublished" datetime="2017-03-21T20:30:29+08:00">2017-03-21 20:30:29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dubbo/" itemprop="url" rel="index"><span itemprop="name">dubbo</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/21/Dubbo中消费者初始化的过程解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>首先还是Spring碰到dubbo的标签之后，会使用parseCustomElement解析dubbo标签，使用的解析器是dubbo的DubboBeanDefinitionParser，解析完成之后返回BeanDefinition给Spring管理。</p>
<p>服务消费者端对应的是ReferenceBean，实现了ApplicationContextAware接口，Spring会在Bean的实例化那一步回调setApplicationContext方法。也实现了InitializingBean接口，接着会回调afterPropertySet方法。还实现了FactoryBean接口，实现FactoryBean可以在后期获取bean的时候做一些操作，dubbo在这个时候做初始化。另外ReferenceBean还实现了DisposableBean，会在bean销毁的时候调用destory方法。</p>
<a id="more"></a>
<p>消费者的初始化是在ReferenceBean的init方法中执行，分为两种情况：</p>
<ul>
<li>reference标签中没有配置init属性，此时是延迟初始化的，也就是只有等到bean引用被注入到其他Bean中，或者调用getBean获取这个Bean的时候，才会初始化。比如在这里的例子里reference没有配置init属性，只有等到<code>HelloService helloService = (HelloService) applicationContext.getBean(&quot;helloService&quot;);</code>这句getBean的时候，才会开始调用init方法进行初始化。</li>
<li>另外一种情况是立即初始化，即是如果reference标签中init属性配置为true，会立即进行初始化（也就是上面说到的实现了FactoryBean接口）。</li>
</ul>
<h1 id="初始化开始"><a href="#初始化开始" class="headerlink" title="初始化开始"></a>初始化开始</h1><p>这里以没有配置init的reference为例，只要不注入bean或者不调用getBean获取bean的时候，就不会被初始化。<code>HelloService helloService = (HelloService) applicationContext.getBean(&quot;helloService&quot;);</code></p>
<p>另外在ReferenceBean这个类在Spring中初始化的时候，有几个静态变量会被初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Protocol refprotocol &#x3D; ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">private static final Cluster cluster &#x3D; ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">private static final ProxyFactory proxyFactory &#x3D; ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>
<p>这几个变量的初始化是根据dubbo的SPI扩展机制动态生成的代码：</p>
<p>refprotocol：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Protocol$Adpative implements com.alibaba.dubbo.rpc.Protocol &#123;</span><br><span class="line">  public com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws java.lang.Class &#123;</span><br><span class="line">    if (arg1 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">    com.alibaba.dubbo.common.URL url &#x3D; arg1;</span><br><span class="line">    String extName &#x3D; ( url.getProtocol() &#x3D;&#x3D; null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line"></span><br><span class="line">    if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.rpc.Protocol extension &#x3D; (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.refer(arg0, arg1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.Invoker &#123;</span><br><span class="line">    if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument &#x3D;&#x3D; null&quot;);</span><br><span class="line">    </span><br><span class="line">    if (arg0.getUrl() &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() &#x3D;&#x3D; null&quot;);com.alibaba.dubbo.common.URL url &#x3D; arg0.getUrl();</span><br><span class="line">    </span><br><span class="line">    String extName &#x3D; ( url.getProtocol() &#x3D;&#x3D; null ? &quot;dubbo&quot; : url.getProtocol() );</span><br><span class="line">    </span><br><span class="line">    if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.rpc.Protocol extension &#x3D; (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.export(arg0);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void destroy() &#123;</span><br><span class="line">  	throw new UnsupportedOperationException(&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int getDefaultPort() &#123;</span><br><span class="line">  	throw new UnsupportedOperationException(&quot;method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cluster：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Cluster$Adpative implements com.alibaba.dubbo.rpc.cluster.Cluster &#123;</span><br><span class="line"></span><br><span class="line">  public com.alibaba.dubbo.rpc.Invoker join(com.alibaba.dubbo.rpc.cluster.Directory arg0) throws com.alibaba.dubbo.rpc.cluster.Directory &#123;</span><br><span class="line">    if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.cluster.Directory argument &#x3D;&#x3D; null&quot;);</span><br><span class="line">    </span><br><span class="line">    if (arg0.getUrl() &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.cluster.Directory argument getUrl() &#x3D;&#x3D; null&quot;);com.alibaba.dubbo.common.URL url &#x3D; arg0.getUrl();</span><br><span class="line">    </span><br><span class="line">    String extName &#x3D; url.getParameter(&quot;cluster&quot;, &quot;failover&quot;);</span><br><span class="line">    if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.cluster.Cluster) name from url(&quot; + url.toString() + &quot;) use keys([cluster])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.rpc.cluster.Cluster extension &#x3D; (com.alibaba.dubbo.rpc.cluster.Cluster)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.join(arg0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>proxyFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class ProxyFactory$Adpative implements com.alibaba.dubbo.rpc.ProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">  public java.lang.Object getProxy(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.Invoker &#123;</span><br><span class="line">    if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument &#x3D;&#x3D; null&quot;);</span><br><span class="line">    </span><br><span class="line">    if (arg0.getUrl() &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() &#x3D;&#x3D; null&quot;);com.alibaba.dubbo.common.URL url &#x3D; arg0.getUrl();</span><br><span class="line">    </span><br><span class="line">    String extName &#x3D; url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">    if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.rpc.ProxyFactory extension &#x3D; (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.getProxy(arg0);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public com.alibaba.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, com.alibaba.dubbo.common.URL arg2) throws java.lang.Object &#123;</span><br><span class="line">    if (arg2 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.common.URL url &#x3D; arg2;</span><br><span class="line">    String extName &#x3D; url.getParameter(&quot;proxy&quot;, &quot;javassist&quot;);</span><br><span class="line">    </span><br><span class="line">    if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.ProxyFactory) name from url(&quot; + url.toString() + &quot;) use keys([proxy])&quot;);</span><br><span class="line">    </span><br><span class="line">    com.alibaba.dubbo.rpc.ProxyFactory extension &#x3D; (com.alibaba.dubbo.rpc.ProxyFactory)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class="line">    </span><br><span class="line">    return extension.getInvoker(arg0, arg1, arg2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="初始化入口"><a href="#初始化入口" class="headerlink" title="初始化入口"></a>初始化入口</h1><p>初始化的入口在ReferenceConfig的get()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized T get() &#123;</span><br><span class="line">  if (destroyed)&#123;</span><br><span class="line">  	throw new IllegalStateException(&quot;Already destroyed!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (ref &#x3D;&#x3D; null) &#123;</span><br><span class="line">  	init();</span><br><span class="line">  &#125;</span><br><span class="line">  return ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init()方法会先检查初始化所有的配置信息，然后调用<code>ref = createProxy(map);</code>创建代理，消费者最终得到的是服务的代理。初始化主要做的事情就是引用对应的远程服务，大概的步骤：</p>
<ul>
<li>监听注册中心</li>
<li>连接服务提供者端进行服务引用</li>
<li>创建服务代理并返回</li>
</ul>
<p>文档上关于Zookeeper作为注册中心时，服务消费者启动时要做的事情有：</p>
<blockquote>
<p>订阅/dubbo/com.foo.BarService/providers目录下的提供者URL地址。<br>并向/dubbo/com.foo.BarService/consumers目录下写入自己的URL地址。</p>
</blockquote>
<h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><ul>
<li>引用远程服务</li>
<li>创建代理</li>
</ul>
<p>init()中createProxy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private T createProxy(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">	&#x2F;&#x2F;先判断是否是本地服务引用injvm</span><br><span class="line">    &#x2F;&#x2F;判断是否是点对点直连</span><br><span class="line">    &#x2F;&#x2F;判断是否是通过注册中心连接</span><br><span class="line">    &#x2F;&#x2F;然后是服务的引用</span><br><span class="line">    &#x2F;&#x2F;这里url为</span><br><span class="line">    &#x2F;&#x2F;registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">    &#x2F;&#x2F;application&#x3D;dubbo-consumer&amp;dubbo&#x3D;2.5.3&amp;pid&#x3D;12272&amp;</span><br><span class="line">    &#x2F;&#x2F;refer&#x3D;application%3Ddubbo-consumer%26dubbo%3D2.5.3%26</span><br><span class="line">    &#x2F;&#x2F;interface%3Ddubbo.common.hello.service.HelloService%26</span><br><span class="line">    &#x2F;&#x2F;methods%3DsayHello%26pid%3D12272%26side%3D</span><br><span class="line">    &#x2F;&#x2F;consumer%26timeout%3D100000%26timestamp%3D1489318676447&amp;</span><br><span class="line">    &#x2F;&#x2F;registry&#x3D;zookeeper&amp;timestamp&#x3D;1489318676641</span><br><span class="line">    &#x2F;&#x2F;引用远程服务由Protocol的实现来处理</span><br><span class="line">    refprotocol.refer(interfaceClass, url);</span><br><span class="line">    &#x2F;&#x2F;最后返回服务代理</span><br><span class="line">     return (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里refprotocol是上面生成的代码，会根据协议不同选择不同的Protocol协议。</p>
<h2 id="引用远程服务"><a href="#引用远程服务" class="headerlink" title="引用远程服务"></a>引用远程服务</h2><p>对于服务引用<code>refprotocol.refer(interfaceClass, url)</code>会首先进入ProtocolListenerWrapper的refer方法，然后在进入ProtocolFilterWrapper的refer方法，然后再进入RegistryProtocol的refer方法，这里的url协议是registry，所以上面两个Wrapper中不做处理，直接进入了RegistryProtocol，看下RegistryProtocol中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123;</span><br><span class="line">	&#x2F;&#x2F;这里获得的url是</span><br><span class="line">    &#x2F;&#x2F;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">    &#x2F;&#x2F;application&#x3D;dubbo-consumer&amp;dubbo&#x3D;2.5.3&amp;pid&#x3D;12272&amp;</span><br><span class="line">    &#x2F;&#x2F;refer&#x3D;application%3Ddubbo-consumer%26dubbo%3D2.5.3%26</span><br><span class="line">    &#x2F;&#x2F;interface%3Ddubbo.common.hello.service.HelloService%26</span><br><span class="line">    &#x2F;&#x2F;methods%3DsayHello%26pid%3D12272%26side%3D</span><br><span class="line">    &#x2F;&#x2F;consumer%26timeout%3D100000%26</span><br><span class="line">    &#x2F;&#x2F;timestamp%3D1489318676447&amp;timestamp&#x3D;1489318676641</span><br><span class="line">    url &#x3D; url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class="line">    &#x2F;&#x2F;根据url获取Registry对象</span><br><span class="line">    &#x2F;&#x2F;先连接注册中心，把消费者注册到注册中心</span><br><span class="line">    Registry registry &#x3D; registryFactory.getRegistry(url);</span><br><span class="line">    &#x2F;&#x2F;判断引用是否是注册中心RegistryService，如果是直接返回刚得到的注册中心服务</span><br><span class="line">    if (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        return proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;以下是普通服务，需要进入注册中心和集群下面的逻辑</span><br><span class="line">    &#x2F;&#x2F; group&#x3D;&quot;a,b&quot; or group&#x3D;&quot;*&quot;</span><br><span class="line">    &#x2F;&#x2F;获取ref的各种属性</span><br><span class="line">    Map&lt;String, String&gt; qs &#x3D; StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line">    &#x2F;&#x2F;获取分组属性</span><br><span class="line">    String group &#x3D; qs.get(Constants.GROUP_KEY);</span><br><span class="line">    &#x2F;&#x2F;先判断引用服务是否需要合并不同实现的返回结果</span><br><span class="line">    if (group !&#x3D; null &amp;&amp; group.length() &gt; 0 ) &#123;</span><br><span class="line">        if ( ( Constants.COMMA_SPLIT_PATTERN.split( group ) ).length &gt; 1</span><br><span class="line">                || &quot;*&quot;.equals( group ) ) &#123;</span><br><span class="line">                &#x2F;&#x2F;使用默认的分组聚合集群策略</span><br><span class="line">            return doRefer( getMergeableCluster(), registry, type, url );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;选择配置的集群策略（cluster&#x3D;&quot;failback&quot;）或者默认策略</span><br><span class="line">    return doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取注册中心"><a href="#获取注册中心" class="headerlink" title="获取注册中心"></a>获取注册中心</h3><p>连接注册中心<code>Registry registry = registryFactory.getRegistry(url);</code>首先会到AbstractRegistryFactory的getRegistry方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public Registry getRegistry(URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;这里url是</span><br><span class="line">    &#x2F;&#x2F;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?</span><br><span class="line">    &#x2F;&#x2F;application&#x3D;dubbo-consumer&amp;dubbo&#x3D;2.5.3&amp;</span><br><span class="line">    &#x2F;&#x2F;interface&#x3D;com.alibaba.dubbo.registry.RegistryService&amp;</span><br><span class="line">    &#x2F;&#x2F;pid&#x3D;12272&amp;timestamp&#x3D;1489318676641</span><br><span class="line">    url &#x3D; url.setPath(RegistryService.class.getName())</span><br><span class="line">            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())</span><br><span class="line">            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);</span><br><span class="line">    &#x2F;&#x2F;这里key是</span><br><span class="line">    &#x2F;&#x2F;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService</span><br><span class="line">    String key &#x3D; url.toServiceString();</span><br><span class="line">    &#x2F;&#x2F; 锁定注册中心获取过程，保证注册中心单一实例</span><br><span class="line">    LOCK.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Registry registry &#x3D; REGISTRIES.get(key);</span><br><span class="line">        if (registry !&#x3D; null) &#123;</span><br><span class="line">            return registry;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里用的是ZookeeperRegistryFactory</span><br><span class="line">        &#x2F;&#x2F;返回的Registry中封装了已经连接到Zookeeper的zkClient实例</span><br><span class="line">        registry &#x3D; createRegistry(url);</span><br><span class="line">        if (registry &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can not create registry &quot; + url);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;放到缓存中</span><br><span class="line">        REGISTRIES.put(key, registry);</span><br><span class="line">        return registry;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 释放锁</span><br><span class="line">        LOCK.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZookeeperRegistryFactory的createRegistry方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Registry createRegistry(URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;直接返回一个新的ZookeeperRegistry实例</span><br><span class="line">    &#x2F;&#x2F;这里的zookeeperTransporter代码在下面，动态生成的适配类</span><br><span class="line">    return new ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zookeeperTransporter代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.alibaba.dubbo.remoting.zookeeper;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class ZookeeperTransporter$Adpative implements com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter &#123;</span><br><span class="line">    public com.alibaba.dubbo.remoting.zookeeper.ZookeeperClient connect(com.alibaba.dubbo.common.URL arg0) &#123;</span><br><span class="line">        if (arg0 &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">        </span><br><span class="line">        com.alibaba.dubbo.common.URL url &#x3D; arg0;</span><br><span class="line">        String extName &#x3D; url.getParameter(&quot;client&quot;, url.getParameter(&quot;transporter&quot;, &quot;zkclient&quot;));</span><br><span class="line">        </span><br><span class="line">        if(extName &#x3D;&#x3D; null) throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter) name from url(&quot; + url.toString() + &quot;) use keys([client, transporter])&quot;);</span><br><span class="line">        </span><br><span class="line">        com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter extension &#x3D; (com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter.class).getExtension(extName);</span><br><span class="line">        </span><br><span class="line">        return extension.connect(arg0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中可以看到，如果我们没有指定Zookeeper的client属性，默认使用zkClient，所以上面的zookeeperTransporter是ZkclientZookeeperTransporter。</p>
<p>继续看<code>new ZookeeperRegistry(url, zookeeperTransporter);</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123;</span><br><span class="line">	&#x2F;&#x2F;这里会先经过AbstractRegistry的处理，然后经过FailbackRegistry的处理（解释在下面）</span><br><span class="line">    super(url);</span><br><span class="line">    if (url.isAnyHost()) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;registry address &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;服务分组，默认dubbo</span><br><span class="line">    String group &#x3D; url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    if (! group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        group &#x3D; Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;注册中心的节点</span><br><span class="line">    this.root &#x3D; group;</span><br><span class="line">    &#x2F;&#x2F;ZkclientZookeeperTransporter的connect方法</span><br><span class="line">    &#x2F;&#x2F;直接返回一个ZkclientZookeeperClient实例</span><br><span class="line">    &#x2F;&#x2F;具体的步骤是，new一个ZkClient实例，然后订阅了一个状态变化的监听器</span><br><span class="line">    zkClient &#x3D; zookeeperTransporter.connect(url);</span><br><span class="line">    &#x2F;&#x2F;添加一个状态改变的监听器</span><br><span class="line">    zkClient.addStateListener(new StateListener() &#123;</span><br><span class="line">        public void stateChanged(int state) &#123;</span><br><span class="line">            if (state &#x3D;&#x3D; RECONNECTED) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRegistry的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public AbstractRegistry(URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;设置registryUrl</span><br><span class="line">    setUrl(url);</span><br><span class="line">    &#x2F;&#x2F; 启动文件保存定时器</span><br><span class="line">    syncSaveFile &#x3D; url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, false);</span><br><span class="line">    &#x2F;&#x2F;会先去用户主目录下的.dubbo目录下加载缓存注册中心的缓存文件比如：dubbo-registry-127.0.0.1.cache</span><br><span class="line">    String filename &#x3D; url.getParameter(Constants.FILE_KEY, System.getProperty(&quot;user.home&quot;) + &quot;&#x2F;.dubbo&#x2F;dubbo-registry-&quot; + url.getHost() + &quot;.cache&quot;);</span><br><span class="line">    File file &#x3D; null;</span><br><span class="line">    if (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">        file &#x3D; new File(filename);</span><br><span class="line">        if(! file.exists() &amp;&amp; file.getParentFile() !&#x3D; null &amp;&amp; ! file.getParentFile().exists())&#123;</span><br><span class="line">            if(! file.getParentFile().mkdirs())&#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Invalid registry store file &quot; + file + &quot;, cause: Failed to create directory &quot; + file.getParentFile() + &quot;!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.file &#x3D; file;</span><br><span class="line">    &#x2F;&#x2F;缓存文件存在的话就把文件读进内存中</span><br><span class="line">    loadProperties();</span><br><span class="line">    &#x2F;&#x2F;先获取backup url</span><br><span class="line">    &#x2F;&#x2F;然后通知订阅</span><br><span class="line">    notify(url.getBackupUrls());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取注册中心时的通知方法"><a href="#获取注册中心时的通知方法" class="headerlink" title="获取注册中心时的通知方法"></a>获取注册中心时的通知方法</h3><p>notify方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    if(urls &#x3D;&#x3D; null || urls.isEmpty()) return;</span><br><span class="line">	&#x2F;&#x2F;getSubscribed()方法获取订阅者列表</span><br><span class="line">    for (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : getSubscribed().entrySet()) &#123;</span><br><span class="line">        URL url &#x3D; entry.getKey();</span><br><span class="line"></span><br><span class="line">        if(! UrlUtils.isMatch(url, urls.get(0))) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners &#x3D; entry.getValue();</span><br><span class="line">        if (listeners !&#x3D; null) &#123;</span><br><span class="line">            for (NotifyListener listener : listeners) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                	&#x2F;&#x2F;通知每个监听器</span><br><span class="line">                    notify(url, listener, filterEmpty(url, urls));</span><br><span class="line">                &#125; catch (Throwable t) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>notify(url, listener, filterEmpty(url, urls));</code>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; result &#x3D; new HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line">    for (URL u : urls) &#123;</span><br><span class="line">        if (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">        	&#x2F;&#x2F;分类</span><br><span class="line">            String category &#x3D; u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">            List&lt;URL&gt; categoryList &#x3D; result.get(category);</span><br><span class="line">            if (categoryList &#x3D;&#x3D; null) &#123;</span><br><span class="line">                categoryList &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">                result.put(category, categoryList);</span><br><span class="line">            &#125;</span><br><span class="line">            categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified &#x3D; notified.get(url);</span><br><span class="line">    if (categoryNotified &#x3D;&#x3D; null) &#123;</span><br><span class="line">        notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">        categoryNotified &#x3D; notified.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">    for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category &#x3D; entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList &#x3D; entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        saveProperties(url);</span><br><span class="line">        &#x2F;&#x2F;通知</span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRegistry构造完，接着是FailbackRegistry的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public FailbackRegistry(URL url) &#123;</span><br><span class="line">    super(url);</span><br><span class="line">    int retryPeriod &#x3D; url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line">    &#x2F;&#x2F;启动失败重试定时器</span><br><span class="line">    this.retryFuture &#x3D; retryExecutor.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; 检测并连接注册中心</span><br><span class="line">            try &#123;</span><br><span class="line">            	&#x2F;&#x2F;重试方法由每个具体子类实现</span><br><span class="line">                &#x2F;&#x2F;获取到注册失败的，然后尝试注册</span><br><span class="line">                retry();</span><br><span class="line">            &#125; catch (Throwable t) &#123; &#x2F;&#x2F; 防御性容错 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会启动一个新的定时线程，主要是有连接失败的话，会进行重试连接retry()，启动完之后返回ZookeeperRegistry中继续处理。接下来下一步是服务的引用。</p>
<h3 id="引用远程服务-1"><a href="#引用远程服务-1" class="headerlink" title="引用远程服务"></a>引用远程服务</h3><p>继续看ref方法中最后一步，服务的引用，返回的是一个Invoker，<code>return doRefer(cluster, registry, type, url)；</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;初始化Directory</span><br><span class="line">    &#x2F;&#x2F;组装Directory，可以看成一个消费端的List，可以随着注册中心的消息推送而动态的变化服务的Invoker</span><br><span class="line">    &#x2F;&#x2F;封装了所有服务真正引用逻辑，覆盖配置，路由规则等逻辑</span><br><span class="line">    &#x2F;&#x2F;初始化时只需要向注册中心发起订阅请求，其他逻辑均是异步处理，包括服务的引用等</span><br><span class="line">    &#x2F;&#x2F;缓存接口所有的提供者端Invoker以及注册中心接口相关的配置等</span><br><span class="line">    RegistryDirectory&lt;T&gt; directory &#x3D; new RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    &#x2F;&#x2F;此处的subscribeUrl为</span><br><span class="line">    &#x2F;&#x2F;consumer:&#x2F;&#x2F;192.168.1.100&#x2F;dubbo.common.hello.service.HelloService?</span><br><span class="line">    &#x2F;&#x2F;application&#x3D;dubbo-consumer&amp;dubbo&#x3D;2.5.3&amp;</span><br><span class="line">    &#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;</span><br><span class="line">    &#x2F;&#x2F;methods&#x3D;sayHello&amp;pid&#x3D;16409&amp;</span><br><span class="line">    &#x2F;&#x2F;side&#x3D;consumer&amp;timeout&#x3D;100000&amp;timestamp&#x3D;1489322133987</span><br><span class="line">    URL subscribeUrl &#x3D; new URL(Constants.CONSUMER_PROTOCOL, NetUtils.getLocalHost(), 0, type.getName(), directory.getUrl().getParameters());</span><br><span class="line">    if (! Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">            &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123;</span><br><span class="line">            &#x2F;&#x2F;到注册中心注册服务</span><br><span class="line">            &#x2F;&#x2F;此处regist是上面一步获得的registry，即是ZookeeperRegistry，包含zkClient的实例</span><br><span class="line">            &#x2F;&#x2F;会先经过AbstractRegistry的处理，然后经过FailbackRegistry的处理（解析在下面）</span><br><span class="line">        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                Constants.CHECK_KEY, String.valueOf(false)));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;订阅服务</span><br><span class="line">    &#x2F;&#x2F;有服务提供的时候，注册中心会推送服务消息给消费者，消费者再进行服务的引用。</span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY, </span><br><span class="line">            Constants.PROVIDERS_CATEGORY </span><br><span class="line">            + &quot;,&quot; + Constants.CONFIGURATORS_CATEGORY </span><br><span class="line">            + &quot;,&quot; + Constants.ROUTERS_CATEGORY));</span><br><span class="line">    &#x2F;&#x2F;服务的引用与变更全部由Directory异步完成</span><br><span class="line">    &#x2F;&#x2F;集群策略会将Directory伪装成一个Invoker返回</span><br><span class="line">    &#x2F;&#x2F;合并所有相同的invoker</span><br><span class="line">    return cluster.join(directory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册中心接收到消费者发送的订阅请求后，会根据提供者注册服务的列表，推送服务消息给消费者。消费者端接收到注册中心发来的提供者列表后，进行服务的引用。触发Directory监听器的可以是订阅请求，覆盖策略消息，路由策略消息。</p>
<h3 id="注册到注册中心"><a href="#注册到注册中心" class="headerlink" title="注册到注册中心"></a>注册到注册中心</h3><p>AbstractRegistry的register方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void register(URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;此时url是</span><br><span class="line">    &#x2F;&#x2F;consumer:&#x2F;&#x2F;192.168.1.100&#x2F;dubbo.common.hello.service.HelloService?</span><br><span class="line">    &#x2F;&#x2F;application&#x3D;dubbo-consumer&amp;</span><br><span class="line">    &#x2F;&#x2F;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.5.3&amp;</span><br><span class="line">    &#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;sayHello</span><br><span class="line">    &#x2F;&#x2F;&amp;pid&#x3D;16409&amp;side&#x3D;consumer&amp;timeout&#x3D;100000&amp;timestamp&#x3D;1489322133987</span><br><span class="line">    if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;register url &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (logger.isInfoEnabled())&#123;</span><br><span class="line">        logger.info(&quot;Register: &quot; + url);</span><br><span class="line">    &#125;</span><br><span class="line">    registered.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是把url添加到registered这个set中。</p>
<p>接着看FailbackRegistry的register方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void register(URL url) &#123;</span><br><span class="line">    super.register(url);</span><br><span class="line">    failedRegistered.remove(url);</span><br><span class="line">    failedUnregistered.remove(url);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 向服务器端发送注册请求</span><br><span class="line">        &#x2F;&#x2F;这里调用的是ZookeeperRegistry中的doRegister方法</span><br><span class="line">        doRegister(url);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Throwable t &#x3D; e;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果开启了启动时检测，则直接抛出异常</span><br><span class="line">        boolean check &#x3D; getUrl().getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.CHECK_KEY, true)</span><br><span class="line">                &amp;&amp; ! Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">        boolean skipFailback &#x3D; t instanceof SkipFailbackWrapperException;</span><br><span class="line">        if (check || skipFailback) &#123;</span><br><span class="line">            if(skipFailback) &#123;</span><br><span class="line">                t &#x3D; t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            throw new IllegalStateException(&quot;Failed to register &quot; + url + &quot; to registry &quot; + getUrl().getAddress() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.error(&quot;Failed to register &quot; + url + &quot;, waiting for retry, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将失败的注册请求记录到失败列表，定时重试</span><br><span class="line">        failedRegistered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看下doRegister(url);方法，向服务器端发送注册请求，在ZookeeperRegistry中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegister(URL url) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;直接调用create，在AbstractZookeeperClient类中</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zkClient.create()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;path为</span><br><span class="line">&#x2F;&#x2F;&#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;consumers&#x2F;</span><br><span class="line">&#x2F;&#x2F;consumer%3A%2F%2F192.168.1.100%2F</span><br><span class="line">&#x2F;&#x2F;dubbo.common.hello.service.HelloService%3Fapplication%3D</span><br><span class="line">&#x2F;&#x2F;dubbo-consumer%26category%3Dconsumers%26check%3Dfalse%26</span><br><span class="line">&#x2F;&#x2F;dubbo%3D2.5.3%26interface%3D</span><br><span class="line">&#x2F;&#x2F;dubbo.common.hello.service.HelloService%26</span><br><span class="line">&#x2F;&#x2F;methods%3DsayHello%26pid%3D28819%26</span><br><span class="line">&#x2F;&#x2F;side%3Dconsumer%26timeout%3D100000%26timestamp%3D1489332839677</span><br><span class="line">public void create(String path, boolean ephemeral) &#123;</span><br><span class="line">    int i &#x3D; path.lastIndexOf(&#39;&#x2F;&#39;);</span><br><span class="line">    if (i &gt; 0) &#123;</span><br><span class="line">        create(path.substring(0, i), false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;循环完得到的path为&#x2F;dubbo</span><br><span class="line">    &#x2F;&#x2F;dynamic&#x3D;false 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心</span><br><span class="line">    if (ephemeral) &#123;</span><br><span class="line">    	&#x2F;&#x2F;创建临时的节点</span><br><span class="line">        createEphemeral(path);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	&#x2F;&#x2F;创建持久的节点，&#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;consumers&#x2F;</span><br><span class="line">        &#x2F;&#x2F;consumer%3A%2F%2F192.168.110.197%2F</span><br><span class="line">        &#x2F;&#x2F;dubbo.common.hello.service.HelloService%3Fapplication%3Ddubbo-consumer%26</span><br><span class="line">        &#x2F;&#x2F;category%3Dconsumers%26check%3Dfalse%26</span><br><span class="line">        &#x2F;&#x2F;dubbo%3D2.5.3%26interface%3D</span><br><span class="line">        &#x2F;&#x2F;dubbo.common.hello.service.HelloService%26</span><br><span class="line">        &#x2F;&#x2F;methods%3DsayHello%26pid%3D6370%26side%3D</span><br><span class="line">        &#x2F;&#x2F;consumer%26timeout%3D100000%26timestamp%3D1489367959659</span><br><span class="line">        createPersistent(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面create之后，Zookeeper中就存在了消费者需要订阅的服务的节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dubbo</span><br><span class="line">	&#x2F;dubbo.common.hello.service.HelloService</span><br><span class="line">    	&#x2F;consumers</span><br><span class="line">        	&#x2F;http:&#x2F;&#x2F;0.0.0.0:4550&#x2F;?path&#x3D;dubbo%2F</span><br><span class="line">            dubbo.common.hello.service.HelloService%2F</span><br><span class="line">            consumers%2Fconsumer%253A%252F%252F192.168.110.197%252F</span><br><span class="line">            dubbo.common.hello.service.HelloService%253F</span><br><span class="line">            application%253Ddubbo-consumer%2526category%253D</span><br><span class="line">            consumers%2526check%253Dfalse%2526</span><br><span class="line">            dubbo%253D2.5.3%2526interface%253D</span><br><span class="line">            dubbo.common.hello.service.HelloService%2526</span><br><span class="line">            methods%253DsayHello%2526pid%253D22392%2526side%253D</span><br><span class="line">            consumer%2526timeout%253D100000%2526timestamp%253D1490063394184</span><br></pre></td></tr></table></figure>
<h3 id="订阅服务提供者"><a href="#订阅服务提供者" class="headerlink" title="订阅服务提供者"></a>订阅服务提供者</h3><p>消费者自己注册到注册中心之后，接着是订阅服务提供者，directory.subscribe()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void subscribe(URL url) &#123;</span><br><span class="line">	&#x2F;&#x2F;设置消费者url</span><br><span class="line">    setConsumerUrl(url);</span><br><span class="line">    &#x2F;&#x2F;这里的registry是ZookeeperRegistry</span><br><span class="line">    registry.subscribe(url, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下registry.subscribe(url, this);，这里registry是ZookeeperRegistry，会先经过AbstractRegistry的处理，然后是FailbackRegistry的处理。</p>
<p>在AbstractRegistry中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此时url为consumer:&#x2F;&#x2F;192.168.1.100&#x2F;dubbo.common.hello.service.HelloService?application&#x3D;dubbo-consumer&amp;</span><br><span class="line">&#x2F;&#x2F;category&#x3D;providers,configurators,routers&amp;dubbo&#x3D;2.5.3&amp;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;</span><br><span class="line">&#x2F;&#x2F;sayHello&amp;pid&#x3D;28819&amp;side&#x3D;consumer&amp;timeout&#x3D;100000&amp;timestamp&#x3D;1489332839677</span><br><span class="line">public void subscribe(URL url, NotifyListener listener) &#123;</span><br><span class="line">	&#x2F;&#x2F;先根据url获取已注册的监听器</span><br><span class="line">    Set&lt;NotifyListener&gt; listeners &#x3D; subscribed.get(url);</span><br><span class="line">    &#x2F;&#x2F;没有监听器，就创建，并添加进去</span><br><span class="line">    if (listeners &#x3D;&#x3D; null) &#123;</span><br><span class="line">        subscribed.putIfAbsent(url, new ConcurrentHashSet&lt;NotifyListener&gt;());</span><br><span class="line">        listeners &#x3D; subscribed.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;有监听器，直接把当前RegistryDirectory添加进去</span><br><span class="line">    listeners.add(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是FailbackRegistry中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void subscribe(URL url, NotifyListener listener) &#123;</span><br><span class="line">    super.subscribe(url, listener);</span><br><span class="line">    removeFailedSubscribed(url, listener);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 向服务器端发送订阅请求</span><br><span class="line">        doSubscribe(url, listener);</span><br><span class="line">    &#125; catch (Exception e) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看doSubscribe(url, listener);向服务端发送订阅请求，在ZookeeperRegistry中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void doSubscribe(final URL url, final NotifyListener listener) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;... &#125; else &#123;</span><br><span class="line">            List&lt;URL&gt; urls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">            for (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners &#x3D; zkListeners.get(url);</span><br><span class="line">                if (listeners &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br><span class="line">                    listeners &#x3D; zkListeners.get(url);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;将zkClient的事件IZkChildListener转换到registry事件NotifyListener</span><br><span class="line">                ChildListener zkListener &#x3D; listeners.get(listener);</span><br><span class="line">                if (zkListener &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    listeners.putIfAbsent(listener, new ChildListener() &#123;</span><br><span class="line">                        public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123;</span><br><span class="line">                            ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    zkListener &#x3D; listeners.get(listener);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;创建三个节点</span><br><span class="line">                &#x2F;&#x2F; &#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;providers&#x2F;</span><br><span class="line">                &#x2F;&#x2F; &#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;configurators&#x2F;</span><br><span class="line">                &#x2F;&#x2F; &#x2F;dubbo&#x2F;dubbo.common.hello.service.HelloService&#x2F;routers&#x2F;</span><br><span class="line">                &#x2F;&#x2F;上面三个路径会被消费者端监听，当提供者，配置，路由发生变化之后，</span><br><span class="line">                &#x2F;&#x2F;注册中心会通知消费者刷新本地缓存。</span><br><span class="line">                zkClient.create(path, false);</span><br><span class="line">                List&lt;String&gt; children &#x3D; zkClient.addChildListener(path, zkListener);</span><br><span class="line">                if (children !&#x3D; null) &#123;</span><br><span class="line">                    urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            notify(url, listener, urls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Failed to subscribe &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务订阅完之后的通知"><a href="#服务订阅完之后的通知" class="headerlink" title="服务订阅完之后的通知"></a>服务订阅完之后的通知</h3><p>服务订阅完成之后，接着就是notify(url, listener, urls);：</p>
<p>会先经过FailbackRegistry将失败的通知请求记录到失败列表，定时重试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        doNotify(url, listener, urls);</span><br><span class="line">    &#125; catch (Exception t) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将失败的通知请求记录到失败列表，定时重试</span><br><span class="line">        Map&lt;NotifyListener, List&lt;URL&gt;&gt; listeners &#x3D; failedNotified.get(url);</span><br><span class="line">        if (listeners &#x3D;&#x3D; null) &#123;</span><br><span class="line">            failedNotified.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, List&lt;URL&gt;&gt;());</span><br><span class="line">            listeners &#x3D; failedNotified.get(url);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.put(listener, urls);</span><br><span class="line">        logger.error(&quot;Failed to notify for subscribe &quot; + url + &quot;, waiting for retry, cause: &quot; + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doNotify(url, listener, urls);：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void doNotify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;</span><br><span class="line">	&#x2F;&#x2F;父类实现</span><br><span class="line">    super.notify(url, listener, urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractRegistry中的doNotify实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; result &#x3D; new HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line">    for (URL u : urls) &#123;</span><br><span class="line">        if (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">        	&#x2F;&#x2F;不同类型的数据分开通知，providers，consumers，routers，overrides</span><br><span class="line">            &#x2F;&#x2F;允许只通知其中一种类型，但该类型的数据必须是全量的，不是增量的。</span><br><span class="line">            String category &#x3D; u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">            List&lt;URL&gt; categoryList &#x3D; result.get(category);</span><br><span class="line">            if (categoryList &#x3D;&#x3D; null) &#123;</span><br><span class="line">                categoryList &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">                result.put(category, categoryList);</span><br><span class="line">            &#125;</span><br><span class="line">            categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (result.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified &#x3D; notified.get(url);</span><br><span class="line">    if (categoryNotified &#x3D;&#x3D; null) &#123;</span><br><span class="line">        notified.putIfAbsent(url, new ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">        categoryNotified &#x3D; notified.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;对这里得到的providers，configurators，routers分别进行通知</span><br><span class="line">    for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category &#x3D; entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList &#x3D; entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        saveProperties(url);</span><br><span class="line">        &#x2F;&#x2F;这里的listener是RegistryDirectory</span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到RegistryDirectory中查看notify方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void notify(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    List&lt;URL&gt; invokerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; routerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; configuratorUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">    for (URL url : urls) &#123;</span><br><span class="line">        String protocol &#x3D; url.getProtocol();</span><br><span class="line">        String category &#x3D; url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">        if (Constants.ROUTERS_CATEGORY.equals(category) </span><br><span class="line">                || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">            routerUrls.add(url);</span><br><span class="line">        &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) </span><br><span class="line">                || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">            configuratorUrls.add(url);</span><br><span class="line">        &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">            invokerUrls.add(url);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.warn(&quot;Unsupported category &quot; + category + &quot; in notified url: &quot; + url + &quot; from registry &quot; + getUrl().getAddress() + &quot; to consumer &quot; + NetUtils.getLocalHost());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; configurators 更新缓存的服务提供方配置</span><br><span class="line">    if (configuratorUrls !&#x3D; null &amp;&amp; configuratorUrls.size() &gt;0 )&#123;</span><br><span class="line">        this.configurators &#x3D; toConfigurators(configuratorUrls);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; routers&#x2F;&#x2F;更新缓存的路由规则配置</span><br><span class="line">    if (routerUrls !&#x3D; null &amp;&amp; routerUrls.size() &gt;0 )&#123;</span><br><span class="line">        List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);</span><br><span class="line">        if(routers !&#x3D; null)&#123; &#x2F;&#x2F; null - do nothing</span><br><span class="line">            setRouters(routers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Configurator&gt; localConfigurators &#x3D; this.configurators; &#x2F;&#x2F; local reference</span><br><span class="line">    &#x2F;&#x2F; 合并override参数</span><br><span class="line">    this.overrideDirectoryUrl &#x3D; directoryUrl;</span><br><span class="line">    if (localConfigurators !&#x3D; null &amp;&amp; localConfigurators.size() &gt; 0) &#123;</span><br><span class="line">        for (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">            this.overrideDirectoryUrl &#x3D; configurator.configure(overrideDirectoryUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; providers</span><br><span class="line">    &#x2F;&#x2F;重建invoker实例</span><br><span class="line">    refreshInvoker(invokerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重建invoker实例"><a href="#重建invoker实例" class="headerlink" title="重建invoker实例"></a>重建invoker实例</h4><p>refreshInvoker(invokerUrls);：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据invokerURL列表转换为invoker列表。转换规则如下：</span><br><span class="line"> * 1.如果url已经被转换为invoker，则不在重新引用，直接从缓存中获取，注意如果url中任何一个参数变更也会重新引用</span><br><span class="line"> * 2.如果传入的invoker列表不为空，则表示最新的invoker列表</span><br><span class="line"> * 3.如果传入的invokerUrl列表是空，则表示只是下发的override规则或route规则，需要重新交叉对比，决定是否需要重新引用。</span><br><span class="line"> * @param invokerUrls 传入的参数不能为null</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void refreshInvoker(List&lt;URL&gt; invokerUrls)&#123;</span><br><span class="line">    if (invokerUrls !&#x3D; null &amp;&amp; invokerUrls.size() &#x3D;&#x3D; 1 &amp;&amp; invokerUrls.get(0) !&#x3D; null</span><br><span class="line">            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">        this.forbidden &#x3D; true; &#x2F;&#x2F; 禁止访问</span><br><span class="line">        this.methodInvokerMap &#x3D; null; &#x2F;&#x2F; 置空列表</span><br><span class="line">        destroyAllInvokers(); &#x2F;&#x2F; 关闭所有Invoker</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.forbidden &#x3D; false; &#x2F;&#x2F; 允许访问</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">        if (invokerUrls.size() &#x3D;&#x3D; 0 &amp;&amp; this.cachedInvokerUrls !&#x3D; null)&#123;</span><br><span class="line">            invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.cachedInvokerUrls &#x3D; new HashSet&lt;URL&gt;();</span><br><span class="line">            this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;缓存invokerUrls列表，便于交叉对比</span><br><span class="line">        &#125;</span><br><span class="line">        if (invokerUrls.size() &#x3D;&#x3D;0 )&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;会重新走一遍服务的引用过程</span><br><span class="line">        &#x2F;&#x2F;给每个提供者创建一个Invoker</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; toInvokers(invokerUrls) ;&#x2F;&#x2F; 将URL列表转成Invoker列表</span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap &#x3D; toMethodInvokers(newUrlInvokerMap); &#x2F;&#x2F; 换方法名映射Invoker列表</span><br><span class="line">        &#x2F;&#x2F; state change</span><br><span class="line">        &#x2F;&#x2F;如果计算错误，则不进行处理.</span><br><span class="line">        if (newUrlInvokerMap &#x3D;&#x3D; null || newUrlInvokerMap.size() &#x3D;&#x3D; 0 )&#123;</span><br><span class="line">            logger.error(new IllegalStateException(&quot;urls to invokers error .invokerUrls.size :&quot;+invokerUrls.size() + &quot;, invoker.size :0. urls :&quot;+invokerUrls.toString()));</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;服务提供者Invoker保存在这个map中</span><br><span class="line">        this.methodInvokerMap &#x3D; multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">        this.urlInvokerMap &#x3D; newUrlInvokerMap;</span><br><span class="line">        try&#123;</span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap,newUrlInvokerMap); &#x2F;&#x2F; 关闭未使用的Invoker</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toInvokers(invokerUrls) 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; new HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    if(urls &#x3D;&#x3D; null || urls.size() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; keys &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">    String queryProtocols &#x3D; this.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line">    for (URL providerUrl : urls) &#123;</span><br><span class="line">    	&#x2F;&#x2F;此时url是dubbo:&#x2F;&#x2F;192.168.110.197:20880&#x2F;dubbo.common.hello.service.HelloService?anyhost&#x3D;true&amp;</span><br><span class="line">        &#x2F;&#x2F;application&#x3D;dubbo-provider&amp;application.version&#x3D;1.0&amp;dubbo&#x3D;2.5.3&amp;environment&#x3D;product&amp;</span><br><span class="line">        &#x2F;&#x2F;interface&#x3D;dubbo.common.hello.service.HelloService&amp;methods&#x3D;sayHello&amp;organization&#x3D;china&amp;</span><br><span class="line">        &#x2F;&#x2F;owner&#x3D;cheng.xi&amp;pid&#x3D;5631&amp;side&#x3D;provider&amp;timestamp&#x3D;1489367571986</span><br><span class="line">        &#x2F;&#x2F;从注册中心获取到的携带提供者信息的url</span><br><span class="line">        &#x2F;&#x2F;如果reference端配置了protocol，则只选择匹配的protocol</span><br><span class="line">        if (queryProtocols !&#x3D; null &amp;&amp; queryProtocols.length() &gt;0) &#123;</span><br><span class="line">            boolean accept &#x3D; false;</span><br><span class="line">            String[] acceptProtocols &#x3D; queryProtocols.split(&quot;,&quot;);</span><br><span class="line">            for (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                if (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                    accept &#x3D; true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!accept) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (! ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">            logger.error(new IllegalStateException(&quot;Unsupported protocol &quot; + providerUrl.getProtocol() + &quot; in notified url: &quot; + providerUrl + &quot; from registry &quot; + getUrl().getAddress() + &quot; to consumer &quot; + NetUtils.getLocalHost() </span><br><span class="line">                    + &quot;, supported protocol: &quot;+ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        URL url &#x3D; mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">        String key &#x3D; url.toFullString(); &#x2F;&#x2F; URL参数是排序的</span><br><span class="line">        if (keys.contains(key)) &#123; &#x2F;&#x2F; 重复URL</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(key);</span><br><span class="line">        &#x2F;&#x2F; 缓存key为没有合并消费端参数的URL，不管消费端如何合并参数，如果服务端URL发生变化，则重新refer</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; localUrlInvokerMap &#x3D;&#x3D; null ? null : localUrlInvokerMap.get(key);</span><br><span class="line">        if (invoker &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 缓存中没有，重新refer</span><br><span class="line">            try &#123;</span><br><span class="line">                boolean enabled &#x3D; true;</span><br><span class="line">                if (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                    enabled &#x3D; ! url.getParameter(Constants.DISABLED_KEY, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    enabled &#x3D; url.getParameter(Constants.ENABLED_KEY, true);</span><br><span class="line">                &#125;</span><br><span class="line">                if (enabled) &#123;</span><br><span class="line">                	&#x2F;&#x2F;根据扩展点加载机制，这里使用的protocol是DubboProtocol</span><br><span class="line">                    invoker &#x3D; new InvokerDelegete&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.error(&quot;Failed to refer invoker for interface:&quot;+serviceType+&quot;,url:(&quot;+url+&quot;)&quot; + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            if (invoker !&#x3D; null) &#123; &#x2F;&#x2F; 将新的引用放入缓存</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">    return newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建invoker <code>invoker = new InvokerDelegete&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</code>：</p>
<ul>
<li>先使用DubboProtocol的refer方法，这一步会依次调用ProtocolFIlterListenerWrapper，ProtocolFilterWrapper，DubboProtocol中的refer方法。经过两个Wrapper中，会添加对应的InvokerListener并构建Invoker Filter链，在DubboProtocol中会创建一个DubboInvoker对象，该Invoker对象持有服务Class，providerUrl，负责和服务提供端通信的ExchangeClient。</li>
<li>接着使用得到的Invoker创建一个InvokerDelegete</li>
</ul>
<h4 id="创建invoker"><a href="#创建invoker" class="headerlink" title="创建invoker"></a>创建invoker</h4><p>在DubboProtocol中创建DubboInvoker的时候代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;</span><br><span class="line">    &#x2F;&#x2F; create rpc invoker.</span><br><span class="line">    &#x2F;&#x2F;这里有一个getClients方法</span><br><span class="line">    DubboInvoker&lt;T&gt; invoker &#x3D; new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">    invokers.add(invoker);</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看getClients方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeClient[] getClients(URL url)&#123;</span><br><span class="line">    &#x2F;&#x2F;是否共享连接</span><br><span class="line">    boolean service_share_connect &#x3D; false;</span><br><span class="line">    int connections &#x3D; url.getParameter(Constants.CONNECTIONS_KEY, 0);</span><br><span class="line">    &#x2F;&#x2F;如果connections不配置，则共享连接，否则每服务每连接</span><br><span class="line">    if (connections &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        service_share_connect &#x3D; true;</span><br><span class="line">        connections &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeClient[] clients &#x3D; new ExchangeClient[connections];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; clients.length; i++) &#123;</span><br><span class="line">        if (service_share_connect)&#123;</span><br><span class="line">        	&#x2F;&#x2F;这里没有配置connections，就使用getSharedClient</span><br><span class="line">            &#x2F;&#x2F;getSharedClient中先去缓存中查找，没有的话就会新建，也是调用initClient方法</span><br><span class="line">            clients[i] &#x3D; getSharedClient(url);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            clients[i] &#x3D; initClient(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看initClient方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建新连接</span><br><span class="line">private ExchangeClient initClient(URL url) &#123;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; client type setting.</span><br><span class="line">    String str &#x3D; url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">    String version &#x3D; url.getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class="line">    boolean compatible &#x3D; (version !&#x3D; null &amp;&amp; version.startsWith(&quot;1.0.&quot;));</span><br><span class="line">    url &#x3D; url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() &amp;&amp; compatible ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);</span><br><span class="line">    &#x2F;&#x2F;默认开启heartbeat</span><br><span class="line">    url &#x3D; url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; BIO存在严重性能问题，暂时不允许使用</span><br><span class="line">    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        throw new RpcException(&quot;Unsupported client type: &quot; + str + &quot;,&quot; +</span><br><span class="line">                &quot; supported client type is &quot; + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), &quot; &quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeClient client ;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;如果lazy属性没有配置为true（我们没有配置，默认为false）ExchangeClient会马上和服务端建立连接</span><br><span class="line">        &#x2F;&#x2F;设置连接应该是lazy的 </span><br><span class="line">        if (url.getParameter(Constants.LAZY_CONNECT_KEY, false))&#123;</span><br><span class="line">            client &#x3D; new LazyConnectExchangeClient(url ,requestHandler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	&#x2F;&#x2F;立即和服务端建立连接</span><br><span class="line">            client &#x3D; Exchangers.connect(url ,requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Fail to create remoting client for service(&quot; + url</span><br><span class="line">                + &quot;): &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    return client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和服务端建立连接，Exchangers.connect(url ,requestHandler);，其实最后使用的是HeaderExchanger，Exchanger目前只有这一个实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">	&#x2F;&#x2F;先经过HeaderExchangeHandler包装</span><br><span class="line">    &#x2F;&#x2F;然后是DecodeHandler</span><br><span class="line">    &#x2F;&#x2F;然后是Transporters.connect</span><br><span class="line">    &#x2F;&#x2F;返回一个HeaderExchangerClient，这里封装了client，channel，启动心跳的定时器等</span><br><span class="line">    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transporters.connect中也是根据SPI扩展获取Transport的具体实现，这里默认使用NettyTransporter.connect()，在NettyTransporter的connect方法中直接返回一个NettyClient(url, listener);，下面看下具体的NettyClient初始化细节，会先初始化AbstractPeer这里只是吧url和handler赋值；然后是AbstractEndpoint初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public AbstractEndpoint(URL url, ChannelHandler handler) &#123;</span><br><span class="line">    super(url, handler);</span><br><span class="line">    &#x2F;&#x2F;获取编解码器，这里是DubboCountCodec</span><br><span class="line">    this.codec &#x3D; getChannelCodec(url);</span><br><span class="line">    this.timeout &#x3D; url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">    this.connectTimeout &#x3D; url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是AbstractClient的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public AbstractClient(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">    super(url, handler);</span><br><span class="line">    send_reconnect &#x3D; url.getParameter(Constants.SEND_RECONNECT_KEY, false);</span><br><span class="line">    shutdown_timeout &#x3D; url.getParameter(Constants.SHUTDOWN_TIMEOUT_KEY, Constants.DEFAULT_SHUTDOWN_TIMEOUT);</span><br><span class="line">    &#x2F;&#x2F;默认重连间隔2s，1800表示1小时warning一次.</span><br><span class="line">    reconnect_warning_period &#x3D; url.getParameter(&quot;reconnect.waring.period&quot;, 1800);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F;具体实现在子类中</span><br><span class="line">        doOpen();</span><br><span class="line">    &#125; catch (Throwable t) &#123;。。。 &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 连接</span><br><span class="line">        connect();</span><br><span class="line">    &#125; catch (RemotingException t) &#123;。。。&#125; </span><br><span class="line">	&#x2F;&#x2F; TODO暂没理解</span><br><span class="line">    executor &#x3D; (ExecutorService) ExtensionLoader.getExtensionLoader(DataStore.class)</span><br><span class="line">        .getDefaultExtension().get(Constants.CONSUMER_SIDE, Integer.toString(url.getPort()));</span><br><span class="line">    ExtensionLoader.getExtensionLoader(DataStore.class)</span><br><span class="line">        .getDefaultExtension().remove(Constants.CONSUMER_SIDE, Integer.toString(url.getPort()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下在NettyClient中doOpen()的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    bootstrap &#x3D; new ClientBootstrap(channelFactory);</span><br><span class="line">    &#x2F;&#x2F; config</span><br><span class="line">    &#x2F;&#x2F; @see org.jboss.netty.channel.socket.SocketChannelConfig</span><br><span class="line">    bootstrap.setOption(&quot;keepAlive&quot;, true);</span><br><span class="line">    bootstrap.setOption(&quot;tcpNoDelay&quot;, true);</span><br><span class="line">    bootstrap.setOption(&quot;connectTimeoutMillis&quot;, getTimeout());</span><br><span class="line">    final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);</span><br><span class="line">    bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">        public ChannelPipeline getPipeline() &#123;</span><br><span class="line">            NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this);</span><br><span class="line">            ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">            pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">            return pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是Netty3中的客户端连接的一些常规步骤，暂不做具体解析。open之后，就是真正连接服务端的操作了，connect()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void connect() throws RemotingException &#123;</span><br><span class="line">    connectLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (isConnected()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;初始化重连的线程</span><br><span class="line">        initConnectStatusCheckCommand();</span><br><span class="line">        &#x2F;&#x2F;连接，在子类中实现</span><br><span class="line">        doConnect();</span><br><span class="line">        reconnect_count.set(0);</span><br><span class="line">        reconnect_error_log_flag.set(false);</span><br><span class="line">    &#125; catch (RemotingException e) &#123;。。。&#125; finally &#123;</span><br><span class="line">        connectLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyClient中的doConnect方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void doConnect() throws Throwable &#123;</span><br><span class="line">    long start &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#x2F;&#x2F;消费者端开始连接，这一步的时候，服务提供者端就接到了连接请求，开始处理了</span><br><span class="line">    ChannelFuture future &#x3D; bootstrap.connect(getConnectAddress());</span><br><span class="line">    try&#123;</span><br><span class="line">        boolean ret &#x3D; future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">        if (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class="line">            Channel newChannel &#x3D; future.getChannel();</span><br><span class="line">            newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 关闭旧的连接</span><br><span class="line">                Channel oldChannel &#x3D; NettyClient.this.channel; &#x2F;&#x2F; copy reference</span><br><span class="line">                if (oldChannel !&#x3D; null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        oldChannel.close();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        NettyChannel.removeChannelIfDisconnected(oldChannel);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (NettyClient.this.isClosed()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        newChannel.close();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        NettyClient.this.channel &#x3D; null;</span><br><span class="line">                        NettyChannel.removeChannelIfDisconnected(newChannel);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    NettyClient.this.channel &#x3D; newChannel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (future.getCause() !&#x3D; null) &#123; throw。。。  &#125; else &#123;throw 。。。 &#125;</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        if (! isConnected()) &#123;</span><br><span class="line">            future.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里连接的细节都交给了netty。</p>
<p>NettyClient初始化完成之后，返回给Transporters，再返回给HeaderExchanger，HeaderExchanger中将NettyClient包装成HeaderExchangeClient返回给DubboProtocol的initClient方法中，到此在getSharedClient中就获取到了一个ExchangeClient，然后包装一下返回<code>client = new ReferenceCountExchangeClient(exchagneclient, ghostClientMap);</code>。</p>
<p>到这里在DubboProtocol的refer方法中这句<code>DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</code>创建DubboInvoker就已经解析完成，创建过程中连接了服务端，包含一个ExchangeClient等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;</span><br><span class="line">    &#x2F;&#x2F; create rpc invoker.</span><br><span class="line">    DubboInvoker&lt;T&gt; invoker &#x3D; new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">    &#x2F;&#x2F;将invoker缓存</span><br><span class="line">    invokers.add(invoker);</span><br><span class="line">    &#x2F;&#x2F;返回invoker</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着返回ProtocolFilterWrapper的refer方法，在这里会构建invoker链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123;</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">        return protocol.refer(type, url);</span><br><span class="line">    &#125;</span><br><span class="line">    return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着再返回到ProtocolListenerWrapper的refer方法，这里会初始化监听器，包装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123;</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">        return protocol.refer(type, url);</span><br><span class="line">    &#125;</span><br><span class="line">    return new ListenerInvokerWrapper&lt;T&gt;(protocol.refer(type, url), </span><br><span class="line">            Collections.unmodifiableList(</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(InvokerListener.class)</span><br><span class="line">                    .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在返回到toInvokers方法，然后返回refreshInvoker方法的<code>Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls) ;</code>这就获得了Invoker，接着就是方法名映射Invoker列表：<code>Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);</code>这里将invokers列表转成与方法的映射关系。到这里refreshInvoker方法就完成了，在往上就返回到AbstractRegistry的notify方法，到这里也完成了。</p>
<h2 id="创建服务代理"><a href="#创建服务代理" class="headerlink" title="创建服务代理"></a>创建服务代理</h2><p>到这里有关消费者端注册到注册中心和订阅注册中心就完事儿了，这部分是在RegistryProtocol.doRefer方法中，这个方法最后一句是<code>return cluster.join(directory);</code>，这里由Cluster组件创建一个Invoker并返回，这里的cluster默认是用FailoverCluster，最后返回的是经过MockClusterInvoker包装过的FailoverCluster。继续返回到ReferenceConfig中createProxy方法，这时候我们已经完成了消费者端引用服务的Invoker。然后最后返回的是根据我们得到的invoker创建的服务代理<code>return (T) proxyFactory.getProxy(invoker);</code>。这里proxyFactory是我们在最上面列出的动态生成的代码。</p>
<p>首先经过AbstractProxyFactory的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces &#x3D; null;</span><br><span class="line">    String config &#x3D; invoker.getUrl().getParameter(&quot;interfaces&quot;);</span><br><span class="line">    if (config !&#x3D; null &amp;&amp; config.length() &gt; 0) &#123;</span><br><span class="line">        String[] types &#x3D; Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">        if (types !&#x3D; null &amp;&amp; types.length &gt; 0) &#123;</span><br><span class="line">            interfaces &#x3D; new Class&lt;?&gt;[types.length + 2];</span><br><span class="line">            interfaces[0] &#x3D; invoker.getInterface();</span><br><span class="line">            interfaces[1] &#x3D; EchoService.class;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; types.length; i ++) &#123;</span><br><span class="line">                interfaces[i + 1] &#x3D; ReflectUtils.forName(types[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (interfaces &#x3D;&#x3D; null) &#123;</span><br><span class="line">        interfaces &#x3D; new Class&lt;?&gt;[] &#123;invoker.getInterface(), EchoService.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里默认使用的是JavassistProxyFactory的实现</span><br><span class="line">    return getProxy(invoker, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后经过StubProxyFactoryWrapper的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    T proxy &#x3D; proxyFactory.getProxy(invoker);</span><br><span class="line">    if (GenericService.class !&#x3D; invoker.getInterface()) &#123;</span><br><span class="line">        String stub &#x3D; invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));</span><br><span class="line">        if (ConfigUtils.isNotEmpty(stub)) &#123;</span><br><span class="line">            Class&lt;?&gt; serviceType &#x3D; invoker.getInterface();</span><br><span class="line">            if (ConfigUtils.isDefault(stub)) &#123;</span><br><span class="line">                if (invoker.getUrl().hasParameter(Constants.STUB_KEY)) &#123;</span><br><span class="line">                    stub &#x3D; serviceType.getName() + &quot;Stub&quot;;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stub &#x3D; serviceType.getName() + &quot;Local&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;?&gt; stubClass &#x3D; ReflectUtils.forName(stub);</span><br><span class="line">                if (! serviceType.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;The stub implemention class &quot; + stubClass.getName() + &quot; not implement interface &quot; + serviceType.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Constructor&lt;?&gt; constructor &#x3D; ReflectUtils.findConstructor(stubClass, serviceType);</span><br><span class="line">                    proxy &#x3D; (T) constructor.newInstance(new Object[] &#123;proxy&#125;);</span><br><span class="line">                    &#x2F;&#x2F;export stub service</span><br><span class="line">                    URL url &#x3D; invoker.getUrl();</span><br><span class="line">                    if (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT))&#123;</span><br><span class="line">                        url &#x3D; url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), &quot;,&quot;));</span><br><span class="line">                        url &#x3D; url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());</span><br><span class="line">                        try&#123;</span><br><span class="line">                            export(proxy, (Class)invoker.getInterface(), url);</span><br><span class="line">                        &#125;catch (Exception e) &#123;</span><br><span class="line">                            LOGGER.error(&quot;export a stub service error.&quot;, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No such constructor \&quot;public &quot; + stubClass.getSimpleName() + &quot;(&quot; + serviceType.getName() + &quot;)\&quot; in stub implemention class &quot; + stubClass.getName(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                LOGGER.error(&quot;Failed to create stub implemention class &quot; + stub + &quot; in consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#x2F;&#x2F; ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回代理。到此<code>HelloService helloService = (HelloService) applicationContext.getBean(&quot;helloService&quot;);</code>就解析完成了，得到了服务的代理，代理会被注册到Spring容器中，可以调用服务方法了。接下来的方法调用过程，是消费者发送请求，提供者处理，然后消费者接受处理结果的请求。</p>
<p>初始化的过程：主要做了注册到注册中心，监听注册中心，连接到服务提供者端，创建代理。这些都是为了下面消费者和提供者之间的通信做准备。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="dachengxi 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="dachengxi 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/dubbo%E6%BA%90%E7%A0%81/" rel="tag"># dubbo源码</a>
              <a href="/tags/dubbo%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="tag"># dubbo消费者初始化</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/03/19/Dubbo%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90/" rel="prev" title="Dubbo中编码和解码的解析">
      <i class="fa fa-chevron-left"></i> Dubbo中编码和解码的解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/03/21/Dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B/" rel="next" title="Dubbo中服务消费者和服务提供者之间的请求和响应过程">
      Dubbo中服务消费者和服务提供者之间的请求和响应过程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化开始"><span class="nav-number">1.</span> <span class="nav-text">初始化开始</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化入口"><span class="nav-number">2.</span> <span class="nav-text">初始化入口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建代理"><span class="nav-number">2.1.</span> <span class="nav-text">创建代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用远程服务"><span class="nav-number">2.2.</span> <span class="nav-text">引用远程服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取注册中心"><span class="nav-number">2.2.1.</span> <span class="nav-text">获取注册中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取注册中心时的通知方法"><span class="nav-number">2.2.2.</span> <span class="nav-text">获取注册中心时的通知方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用远程服务-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">引用远程服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册到注册中心"><span class="nav-number">2.2.4.</span> <span class="nav-text">注册到注册中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅服务提供者"><span class="nav-number">2.2.5.</span> <span class="nav-text">订阅服务提供者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务订阅完之后的通知"><span class="nav-number">2.2.6.</span> <span class="nav-text">服务订阅完之后的通知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重建invoker实例"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">重建invoker实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建invoker"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">创建invoker</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建服务代理"><span class="nav-number">2.3.</span> <span class="nav-text">创建服务代理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dachengxi"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">dachengxi</p>
  <div class="site-description" itemprop="description">一个小学生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">97</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dachengxi" title="GitHub → https://github.com/dachengxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/dachengxi" title="微博 → http://weibo.com/dachengxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>微博</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://git.oschina.net/dachengxi" title="码云 → http://git.oschina.net/dachengxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-git"></i>码云</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://hexo.io" title="http://hexo.io" rel="noopener" target="_blank">Hexo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/iissnan/hexo-theme-next" title="https://github.com/iissnan/hexo-theme-next" rel="noopener" target="_blank">Next Theme</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dachengxi</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://cxis.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://dachengxi.github.com/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/";
    this.page.identifier = "2017/03/21/Dubbo中消费者初始化的过程解析/";
    this.page.title = "Dubbo中消费者初始化的过程解析";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://cxis.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

  <a href="https://github.com/dachengxi" target="_blank" rel="noopener"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
