<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dubbo on Time Stream</title>
    <link>https://cxis.me/categories/dubbo/</link>
    <description>Recent content in dubbo on Time Stream</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>cxis</copyright>
    <lastBuildDate>Fri, 20 Mar 2020 23:25:44 +0000</lastBuildDate>
    
	<atom:link href="https://cxis.me/categories/dubbo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dubbo启动以及服务调用的过程总结</title>
      <link>https://cxis.me/2020/03/20/Dubbo%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 20 Mar 2020 23:25:44 +0000</pubDate>
      
      <guid>https://cxis.me/2020/03/20/Dubbo%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;服务暴露过程、服务引用过程、服务调用过程、消费者调用底层通信过程、提供者接受请求底层通信过程简单总结。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo架构简单理解</title>
      <link>https://cxis.me/2020/03/19/Dubbo%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</link>
      <pubDate>Thu, 19 Mar 2020 22:32:11 +0000</pubDate>
      
      <guid>https://cxis.me/2020/03/19/Dubbo%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;分析总结一下Dubbo的架构，通过对Dubbo、RocketMQ、Tair等架构的类比，从整体上来理解一般分布式框架、应用的组成。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中SPI源码解析</title>
      <link>https://cxis.me/2019/02/20/Dubbo%E4%B8%ADSPI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 20 Feb 2019 20:15:34 +0000</pubDate>
      
      <guid>https://cxis.me/2019/02/20/Dubbo%E4%B8%ADSPI%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;从两个示例代码，介绍dubbo的SPI的使用以及相关源码分析，分析了获取扩展实现和获取自适应扩展点实现的源码，最后简单说了下ExtensionFactory的流程，看完就可以理解为什么dubbo是自包含的了。从上往下看，再回头看，应该能看明白，文章比较长，希望能耐心读下去。如果有错误的地方希望能指出来，我也理解不是太完整或者表述不是太明白。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中Directory解析</title>
      <link>https://cxis.me/2017/04/02/Dubbo%E4%B8%ADDirectory%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 02 Apr 2017 23:38:55 +0000</pubDate>
      
      <guid>https://cxis.me/2017/04/02/Dubbo%E4%B8%ADDirectory%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Directory代表多个Invoker，可以把它看成List&lt;!-- raw HTML omitted --&gt;，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中订阅和通知解析</title>
      <link>https://cxis.me/2017/04/02/Dubbo%E4%B8%AD%E8%AE%A2%E9%98%85%E5%92%8C%E9%80%9A%E7%9F%A5%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 02 Apr 2017 20:02:46 +0000</pubDate>
      
      <guid>https://cxis.me/2017/04/02/Dubbo%E4%B8%AD%E8%AE%A2%E9%98%85%E5%92%8C%E9%80%9A%E7%9F%A5%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;Dubbo中关于服务的订阅和通知主要发生在服务提供方暴露服务的过程和服务消费方初始化时候引用服务的过程中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中集群Cluster，负载均衡，容错，路由解析</title>
      <link>https://cxis.me/2017/03/26/Dubbo%E4%B8%AD%E9%9B%86%E7%BE%A4Cluster%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%B9%E9%94%99%E8%B7%AF%E7%94%B1%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 26 Mar 2017 12:12:49 +0000</pubDate>
      
      <guid>https://cxis.me/2017/03/26/Dubbo%E4%B8%AD%E9%9B%86%E7%BE%A4Cluster%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%B9%E9%94%99%E8%B7%AF%E7%94%B1%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;Dubbo中的Cluster可以将多个服务提供方伪装成一个提供方，具体也就是将Directory中的多个Invoker伪装成一个Invoker，在伪装的过程中包含了容错的处理，负载均衡的处理和路由的处理。这篇文章介绍下集群相关的东西，开始先对着文档解释下容错模式，负载均衡，路由等概念，然后解析下源码的处理。（稍微有点乱，心情不太好，不适合分析源码。）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中服务消费者和服务提供者之间的请求和响应过程</title>
      <link>https://cxis.me/2017/03/21/Dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 21 Mar 2017 23:58:13 +0000</pubDate>
      
      <guid>https://cxis.me/2017/03/21/Dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;服务提供者初始化完成之后，对外暴露Exporter。服务消费者初始化完成之后，得到的是Proxy代理，方法调用的时候就是调用代理。&lt;/p&gt;
&lt;p&gt;服务消费者经过初始化之后，得到的是一个动态代理类，InvokerInvocationHandler，包含MockClusterInvoker，MockClusterInvoker包含一个RegistryDirectory和FailoverClusterInvoker。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中消费者初始化的过程解析</title>
      <link>https://cxis.me/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 21 Mar 2017 20:30:29 +0000</pubDate>
      
      <guid>https://cxis.me/2017/03/21/Dubbo%E4%B8%AD%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;首先还是Spring碰到dubbo的标签之后，会使用parseCustomElement解析dubbo标签，使用的解析器是dubbo的DubboBeanDefinitionParser，解析完成之后返回BeanDefinition给Spring管理。&lt;/p&gt;
&lt;p&gt;服务消费者端对应的是ReferenceBean，实现了ApplicationContextAware接口，Spring会在Bean的实例化那一步回调setApplicationContext方法。也实现了InitializingBean接口，接着会回调afterPropertySet方法。还实现了FactoryBean接口，实现FactoryBean可以在后期获取bean的时候做一些操作，dubbo在这个时候做初始化。另外ReferenceBean还实现了DisposableBean，会在bean销毁的时候调用destory方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中编码和解码的解析</title>
      <link>https://cxis.me/2017/03/19/Dubbo%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 19 Mar 2017 23:25:51 +0000</pubDate>
      
      <guid>https://cxis.me/2017/03/19/Dubbo%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90/</guid>
      <description>（这里做的解析不是很详细，等到走完整个流程再来解析）Dubbo中编解码的工作由Codec2接口的实现来处理，回想一下第一次接触到Codec2</description>
    </item>
    
    <item>
      <title>Dubbo中暴露服务的过程解析</title>
      <link>https://cxis.me/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 19 Feb 2017 00:46:14 +0000</pubDate>
      
      <guid>https://cxis.me/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=&amp;quot;5000&amp;rdquo;），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=&amp;rdquo;-1&amp;rdquo;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。&lt;/li&gt;
&lt;li&gt;没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是不管延迟与否，都是使用ServiceConfig的export()方法进行服务的暴露。使用export初始化的时候会将Bean对象转换成URL格式，所有Bean属性转换成URL的参数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dubbo中SPI扩展机制详解</title>
      <link>https://cxis.me/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 18 Feb 2017 23:13:34 +0000</pubDate>
      
      <guid>https://cxis.me/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;前面我们了解过了Java的SPI扩展机制，对于Java扩展机制的原理以及优缺点也有了大概的了解，这里继续深入一下Dubbo的扩展点加载机制。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>