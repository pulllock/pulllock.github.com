<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Java基础之ConcurrentHashMap简介</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	=============<br>
	== <a href="https://cxis.me/">cxis.me</a> ==<br>
	=============
	<div style="float: right;">脚踏实地</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories"><b>Categories</b></a>.
			
			<a href="/tags"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Java基础之ConcurrentHashMap简介</h1>
			<b><time>2016-05-26 11:00:23</time></b>
		       

			<div>
				<p>基于JDK1.8，重新梳理ConcurrentHashMap。</p>
<p>JDK1.7中ConcurrentHashMap是使用分段锁来实现的，分段锁其实还是独占锁。而JDK1.8中ConcurrentHashMap的实现感觉起来更加轻量，使用cas+volatile+synchronized来保证并发安全，整体结构和HashMap类似，采用数组存储元素，冲突解决使用链表加红黑树的方式。</p>
<p>ConcurrentHashMap和HashMap的存储结构稍有不同，HashMap中数组存储的是Node类型结点，有冲突时，先是Node结点组成链表，转化为树的时候则是使用TreeNode类型结点。ConcurrentHashMap中数组存储的也是Node类型结点，冲突时先是Node结点组成链表，转化为树的时候有一点不同，树的根结点使用的是TreeBin，树的其他结点使用的是TreeNode。</p>
<h1 id="concurrenthashmap中的各个结点的类型">ConcurrentHashMap中的各个结点的类型</h1>
<ul>
<li>Node，链表中使用的结点类型，结点的哈希值是正常的</li>
<li>TreeNode，红黑树中使用的结点类型，结点的哈希值是正常的</li>
<li>TreeBin，如果是红黑树，数组中存储的是TreeBin，TreeBin中持有红黑树，结点的哈希值是-2</li>
<li>ForwardingNode，在数组扩容的时候使用，当在扩容的时候，如果一个桶位置处的元素已经全部转移完，则在桶中存放一个ForwardingNode，指向新数组，结点的哈希值是-1</li>
<li>ReservationNode，占位符，在compute方法计算的时候使用，结点的哈希值是-3</li>
</ul>
<h1 id="concurrenthashmap的get操作是怎么保证线程安全的">ConcurrentHashMap的get操作是怎么保证线程安全的？</h1>
<p>ConcurrentHashMap中get方法没有使用锁，但却是线程安全的。当使用get方法读取ConcurrentHashMap的时候，其实是根据key的哈希值读取数组中某个桶位置处的元素，在数组中可能读到的元素有：</p>
<ul>
<li>Node，说明当前桶中是链表</li>
<li>TreeBin，说明当前桶中是一颗红黑树</li>
<li>ForwardingNode，说明当前桶中元素已经被转移到了新数组中的桶中</li>
<li>ReservationNode，说明compute方法正在计算中</li>
</ul>
<p>读到桶中是不同类型的结点时，也会有各种不同情况发生：</p>
<ul>
<li>有线程正在写数据到这个桶中，ConcurrentHashMap写是多线程的，但是针对单个桶的写是单线程的，需要加锁。</li>
<li>数组可能正在扩容，当前槽正在被转移</li>
<li>如果桶中是链表，可能正在树化</li>
<li>如果桶中是红黑树，可能正在链表化</li>
</ul>
<h2 id="如果读到的桶中是个链表">如果读到的桶中是个链表</h2>
<p>如果读到的桶中是个链表，可能会有如下情况正在发生：</p>
<ul>
<li>链表正在树化，链表树化会将Node转化为TreeNode，但是原来链表的结构没有变化，此时仍可以按照链表方式进行读取元素，没有线程安全问题。</li>
<li>链表正在被转移，扩容转移的时候不会破坏原来链表的结构，此时读取链表数据是没有线程安全问题的。</li>
<li>链表正在被写（put、remove、replace），由于写链表的时候会加锁，因此只有一个线程在写链表。put新元素的时候是在链表尾部进行，对读取没有影响；remove的时候结点的next指针没有变化，因此还可以继续遍历链表，没有影响；replace只是替换元素，不会改变链表结构，因此也不会产生线程安全问题。</li>
</ul>
<h2 id="如果读到的桶中是红黑树">如果读到的桶中是红黑树</h2>
<p>如果读到的桶中是红黑树，可能有如下情况正在发生：</p>
<ul>
<li>红黑树正在链表化，红黑树进行链表化的时候不会破坏红黑树的结构，因此读取红黑树不会有线程安全问题。</li>
<li>红黑树正在被转移，扩容转移的时候原来红黑树结构也不会被破坏，此时读取红黑树不会有线程安全问题。</li>
<li>红黑树正在被写（put、remove、replace），读取的时候正好红黑树被写，此时会先按链表进行遍历，虽然效率低，但是最起码能读取元素。每次遍历链表一个元素，都会检查下红黑树的写锁有没有被释放，如果被释放就转换成红黑树读取，效率高。树的查找也会加读锁。</li>
</ul>
<h2 id="如果读取的桶中是forwardingnode">如果读取的桶中是ForwardingNode</h2>
<p>如果读取到的桶中是ForwardingNode，说明当前桶已经被转移完成了，ForwardingNode中有指向新数组的指针，直接到新数组中去读取。</p>
<h2 id="如果读取的桶中是reservationnode">如果读取的桶中是ReservationNode</h2>
<p>如果读取的桶中是ReservationNode，说明compute方法正在计算，此时读取直接返回null。</p>
<h1 id="concurrenthashmap的写安全">ConcurrentHashMap的写安全</h1>
<p>ConcurrentHashMap写使用自旋+cas+synchronized来实现，将数据写入到某个桶的时候，会锁住该桶，只能有一个线程进行写，但是能并发进行读操作。</p>
<p>对于链表结构，单线程写链表尾部，不会有线程安全问题。</p>
<p>对于红黑树结构，本身会有简单的读写锁进行控制，也不会有线程安全问题。</p>
<h1 id="concurrenthashmap的扩容和转移机制">ConcurrentHashMap的扩容和转移机制</h1>
<p>扩容的时候，从数组的最后开始往前处理，每个线程处理一个区间段的数组，使用transferIndex来控制每个线程要处理的区间段。一个线程处理一个区间段的数组时，回从后往前，挨个处理每个桶，处理每个桶的时候会加锁并转移数据。</p>
<p>转移数据的时候将数据分为两部分，一部分是结点哈希值和桶中链表长度取余为0的，这部分结点放到新的数组中的相同的桶中；另外一部分是取余为1的数据，这部分数据放到新数组的：原来桶索引+原数组长度的位置。</p>
<p>每个桶的数据转移完后，将桶中修改成ForwardingNode，用来指向新数组。</p>
<h1 id="concurrenthashmap的并发计数机制">ConcurrentHashMap的并发计数机制</h1>
<p>ConcurrentHashMap的并发计数机制和LongAdder的实现机制一样，采用baseCount+一个计数数组实现，baseCount和计数数组中所有元素的和才是真正的size。</p>
<p>当没有竞争的时候，会先写baseCount，此时baseCount就是map的大小；当有竞争的时候，就会将每次新增大小累加到一个Cell数组中去。当有统计size大小的时候，就将baseCount和Cell数组中所有元素进行求和。</p>
<p>Cell元素是经过内存对齐的，每个Cell可以独占一个缓存行，这样可以防止伪共享的问题。</p>
<p>这样可以将对一个共享变量的读写转移到一个数组不同位置的读写，增加并发写的效率。</p>
<h1 id="源码分析">源码分析</h1>
<p>参照源码解析：<a href="https://github.com/dachengxi/Java8u192SourceCode">https://github.com/dachengxi/Java8u192SourceCode</a></p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://my.oschina.net/qq785482254/blog/4307177">https://my.oschina.net/qq785482254/blog/4307177</a></li>
<li><a href="https://segmentfault.com/a/1190000024528036">https://segmentfault.com/a/1190000024528036</a></li>
</ul>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/2021/03/18/%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95/">基础之零拷贝相关知识总结记录</a></li>
				
				<li><a href="/2021/03/17/%E5%9F%BA%E7%A1%80%E4%B9%8BCPUCacheMESI%E7%AD%89%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95/">基础之CPU、Cache、MESI等相关知识总结记录</a></li>
				
				<li><a href="/2021/03/15/%E5%9F%BA%E7%A1%80%E4%B9%8BIO%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/">基础之IO的同步、异步、阻塞、非阻塞</a></li>
				
				<li><a href="/2020/11/02/MyBatis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/">MyBatis启动过程介绍</a></li>
				
				<li><a href="/2020/10/26/SpringBoot%E4%B8%AD%E6%89%A9%E5%B1%95%E7%82%B9%E6%B1%87%E6%80%BB/">SpringBoot中扩展点汇总</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2021 <a href="https://cxis.me/"><b>cxis</b></a>.
	<a href="https://gohugo.io/"><b>Hugo</b></a>.
	<a href="https://github.com/colorchestra/smol"><b>Smol</b></a>.
	<a href="https://github.com/dachengxi"><b>Github</b></a>.
	</p>
</footer>

</body>
<script>
    window.MathJax = {
    tex: {
      tags: 'ams',  
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-svg.min.js" integrity="sha512-cvY8FLZ100SA0lUHyX38BDEr1rz0AKP6Iz+t5yfOPOyuKX72RNHIuPGH/+ScEsbKBhngYhKJSaFbtKet0te1Sw==" crossorigin="anonymous"></script>
</html>
