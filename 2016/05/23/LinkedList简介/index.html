<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>LinkedList简介</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	

</head>
<body>
	<header>
	=================<br>
	== <a href="https://cxis.me/">Time Stream</a> ==<br>
	=================
	<div style="float: right;">一个小学生</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories"><b>Categories</b></a>.
			
			<a href="/tags"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>LinkedList简介</h1>
			<b><time>2016-05-23 23:20:51</time></b>
		       
		           <a href="/tags/linkedList">linkedList</a>
        	       

			<div>
				<h1 id="linkedlist简介">LinkedList简介</h1>
<ol>
<li>LinkedList基于双向链表实现</li>
<li>LinkedList相对于Arraylist来说,get和set等随机访问会比较慢,LinkedList需要移动指针；add和remove会比较快。</li>
<li>LinkedList类还为在列表开头和结尾的get，remove，insert元素提供统一的命名方法，这些操作允许将链表用做堆栈、队列或者双端队列。此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</li>
<li>非线程安全，不同步。</li>
</ol>
<h1 id="定义">定义</h1>
<p>LinkedList集成AbstractSequentialList，实现了List，Deque，Cloneable，Serializable接口。AbstractSequentialList提供了骨干实现。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。</p>
<h1 id="源码分析">源码分析</h1>
<blockquote>
<p>jdk1.7.0_71</p>
</blockquote>
<pre><code>//节点个数
transient int size = 0;
//前驱节点
transient Node&lt;E&gt; first;
//后继节点
transient Node&lt;E&gt; last;
</code></pre><h2 id="无参构造">无参构造</h2>
<pre><code>public LinkedList() {}
</code></pre><h2 id="根据其他容器进行构造">根据其他容器进行构造</h2>
<pre><code>public LinkedList(Collection&lt;? extends E&gt; c) {}
</code></pre><h2 id="getfirstgetlast-获取第一个获取最后一个">getFirst()/getLast() 获取第一个/获取最后一个</h2>
<pre><code>public E getFirst() {}
public E getLast() {}
</code></pre><h2 id="removefirstremovelast-删除第一个删除最后一个">removeFirst()/removeLast() 删除第一个/删除最后一个</h2>
<pre><code>public E removeFirst() {}
public E removeLast() {}
</code></pre><h2 id="addfirste-eaddlaste-e-添加到头尾">addFirst(E e)/addLast(E e) 添加到头/尾</h2>
<pre><code>public void addFirst(E e) {}
public void addLast(E e) {}
</code></pre><h2 id="是否包含指定的元素">是否包含指定的元素</h2>
<pre><code>public boolean contains(Object o) {
	return indexOf(o) != -1;
}
</code></pre><h2 id="指定元素的位置索引">指定元素的位置索引</h2>
<pre><code>public int indexOf(Object o) {}
</code></pre><h2 id="指定元素的最后的位置索引">指定元素的最后的位置索引</h2>
<pre><code>public int lastIndexOf(Object o) {}
</code></pre><h2 id="list的大小">list的大小</h2>
<pre><code>public int size() {
        return size;
}
</code></pre><h2 id="add-添加到末尾">add() 添加到末尾</h2>
<pre><code>public boolean add(E e) {}
</code></pre><h2 id="removeobject-oremovefirstoccurrenceobject-o-移除第一个o">remove(Object o)/removeFirstOccurrence(Object o) 移除第一个o</h2>
<pre><code>public boolean remove(Object o) {}

public boolean removeFirstOccurrence(Object o){}
</code></pre><h2 id="addallcollection-extends-e-c-添加到list结尾">addAll(Collection&lt;? extends E&gt; c) 添加到list结尾</h2>
<pre><code>public boolean addAll(Collection&lt;? extends E&gt; c) {}
</code></pre><h2 id="addallint-index-collection-extends-e-c-指定的位置以后添加全部">addAll(int index, Collection&lt;? extends E&gt; c) 指定的位置以后添加全部</h2>
<pre><code>public boolean addAll(int index, Collection&lt;? extends E&gt; c) {}
</code></pre><h2 id="clear-清空">clear() 清空</h2>
<pre><code>public void clear() {}
</code></pre><h2 id="getint-index-获取指定位置的元素">get(int index) 获取指定位置的元素</h2>
<pre><code>public E get(int index) {}
</code></pre><h2 id="指定位置替换成新元素返回旧元素">指定位置替换成新元素,返回旧元素</h2>
<pre><code>public E set(int index, E element) {}
</code></pre><h2 id="addint-index-e-element指定位置插入指定元素">add(int index, E element)指定位置插入指定元素</h2>
<pre><code>public void add(int index, E element) {}
</code></pre><h2 id="removeint-index-移除指定位置的元素">remove(int index) 移除指定位置的元素</h2>
<pre><code>public E remove(int index) {}
</code></pre><h2 id="peekpeekfirst-获取list头">peek()/peekFirst() 获取list头</h2>
<pre><code>public E peek() {}

public E peekFirst() {}
</code></pre><h2 id="element-获取list头">element() 获取list头</h2>
<pre><code>public E element() {}
</code></pre><h2 id="pollpollfirst-获取list头并删除">poll()/pollFirst() 获取list头,并删除</h2>
<pre><code>public E poll() {}

public E pollFirst() {}
</code></pre><h2 id="remove-删除第一个">remove() 删除第一个</h2>
<pre><code>public E remove() {}
</code></pre><h2 id="offere-eofferlaste-e-添加e到尾部">offer(E e)/offerLast(E e) 添加e到尾部</h2>
<pre><code>public boolean offer(E e) {}

public boolean offerLast(E e) {}
</code></pre><h2 id="offerfirste-epushe-e-添加e到头部">offerFirst(E e)/push(E e) 添加e到头部</h2>
<pre><code>public boolean offerFirst(E e) {}

public void push(E e){}
</code></pre><h2 id="peeklast-获取list尾">peekLast() 获取list尾</h2>
<pre><code>public E peekLast() {}
</code></pre><h2 id="polllast-获取list尾并删除">pollLast() 获取list尾,并删除</h2>
<pre><code>public E pollLast
</code></pre><h2 id="pop-删除头">pop() 删除头</h2>
<pre><code>public E pop(){}
</code></pre><h2 id="removelastoccurrenceobject-o从后面开始删除第一个匹配的元素">removeLastOccurrence(Object o)从后面开始删除第一个匹配的元素</h2>
<pre><code>public boolean removeLastOccurrence(Object o) {}
</code></pre><h2 id="listiteratorint-index从指定的位置开始返回一个listiterator">listIterator(int index)从指定的位置开始返回一个listIterator</h2>
<pre><code>public ListIterator&lt;E&gt; listIterator(int index) {}
</code></pre><h2 id="descendingiterator-逆序迭代器">descendingIterator() 逆序迭代器</h2>
<pre><code>public Iterator&lt;E&gt; descendingIterator() {
		//内部类
        return new DescendingIterator();
    }
</code></pre><h2 id="clone-浅拷贝">clone() 浅拷贝</h2>
<pre><code>public Object clone() {}
</code></pre><h2 id="toarray-转换成object数组">toArray() 转换成Object数组</h2>
<pre><code>public Object[] toArray() {}
</code></pre><h2 id="toarrayt-a-转换成指定类型的数组">toArray(T[] a) 转换成指定类型的数组</h2>
<pre><code>public &lt;T&gt; T[] toArray(T[] a) {
        if (a.length &lt; size)
            a = (T[])java.lang.reflect.Array.newInstance(
                                a.getClass().getComponentType(), size);
        int i = 0;
        Object[] result = a;
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            result[i++] = x.item;

        if (a.length &gt; size)
            a[size] = null;

        return a;
    }
</code></pre><h1 id="参考">参考</h1>
<p><a href="https://www.zybuluo.com/pastqing/note/208830">https://www.zybuluo.com/pastqing/note/208830</a></p>
<p><a href="http://blog.csdn.net/u013256816/article/details/50916689">http://blog.csdn.net/u013256816/article/details/50916689</a></p>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/2021/02/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E6%AF%94%E8%BE%83/">算法之各类排序算法总结比较</a></li>
				
				<li><a href="/2021/02/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之归并排序学习</a></li>
				
				<li><a href="/2021/02/28/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之堆排序学习</a></li>
				
				<li><a href="/2021/02/23/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之直接选择排序学习</a></li>
				
				<li><a href="/2021/02/20/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%88%90%E5%AF%B9%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0/">算法之成对插入排序学习</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2021 <a href="https://cxis.me/"><b>cxis</b></a>.
	<a href="https://gohugo.io/"><b>Hugo</b></a>.
	<a href="https://github.com/colorchestra/smol"><b>Smol</b></a>.
	<a href="https://github.com/dachengxi"><b>Github</b></a>.
	</p>
</footer>

</body>
<script>
    window.MathJax = {
    tex: {
      tags: 'ams',  
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-svg.min.js" integrity="sha512-cvY8FLZ100SA0lUHyX38BDEr1rz0AKP6Iz+t5yfOPOyuKX72RNHIuPGH/+ScEsbKBhngYhKJSaFbtKet0te1Sw==" crossorigin="anonymous"></script>
</html>
