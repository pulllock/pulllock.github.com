<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta name="generator" content="Hugo 0.67.1" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Time Stream</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="Time Stream">

</head>
<body>
	<header>
	=================<br>
	== <a href="https://cxis.me/">Time Stream</a> ==<br>
	=================
	<div style="float: right;">一个小学生</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories"><b>Categories</b></a>.
			
			<a href="/tags"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		
		
			<article>
	<h1><a href="https://cxis.me/2017/03/19/Dubbo%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90/">Dubbo中编码和解码的解析</a></h1>
	<b><time>2017-03-19 23:25:51</time></b>
	
	<a href="/tags/dubbo%E7%BC%96%E8%A7%A3%E7%A0%81">dubbo编解码</a>
	
	<a href="/tags/dubbo%E6%BA%90%E7%A0%81">dubbo源码</a>
	
	<div>
		（这里做的解析不是很详细，等到走完整个流程再来解析）Dubbo中编解码的工作由Codec2接口的实现来处理，回想一下第一次接触到Codec2
		
			<a href="https://cxis.me/2017/03/19/Dubbo%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2017/03/19/Netty3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/">Netty3服务端流程简介</a></h1>
	<b><time>2017-03-19 20:27:39</time></b>
	
	<a href="/tags/Netty3">Netty3</a>
	
	<a href="/tags/Netty3%E6%B5%81%E7%A8%8B">Netty3流程</a>
	
	<div>
		<p>在学习Dubbo的时候需要学习Netty的流程等，在此做一个简单的入门学习。Dubbo中使用的是Netty3，所以这里说的都是Netty3。</p>
<p>Netty3可以看成是对Reactor的实现，所以先简单看下Reactor模式。</p>
		
			<a href="https://cxis.me/2017/03/19/Netty3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">Dubbo中暴露服务的过程解析</a></h1>
	<b><time>2017-02-19 00:46:14</time></b>
	
	<a href="/tags/dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2">dubbo服务暴露</a>
	
	<a href="/tags/dubbo%E6%BA%90%E7%A0%81">dubbo源码</a>
	
	<div>
		<p>dubbo暴露服务有两种情况，一种是设置了延迟暴露（比如delay=&quot;5000&rdquo;），另外一种是没有设置延迟暴露或者延迟设置为-1（delay=&rdquo;-1&rdquo;）：</p>
<ul>
<li>设置了延迟暴露，dubbo在Spring实例化bean（initializeBean）的时候会对实现了InitializingBean的类进行回调，回调方法是afterPropertySet()，如果设置了延迟暴露，dubbo在这个方法中进行服务的发布。</li>
<li>没有设置延迟或者延迟为-1，dubbo会在Spring实例化完bean之后，在刷新容器最后一步发布ContextRefreshEvent事件的时候，通知实现了ApplicationListener的类进行回调onApplicationEvent，dubbo会在这个方法中发布服务。</li>
</ul>
<p>但是不管延迟与否，都是使用ServiceConfig的export()方法进行服务的暴露。使用export初始化的时候会将Bean对象转换成URL格式，所有Bean属性转换成URL的参数。</p>
		
			<a href="https://cxis.me/2017/02/19/Dubbo%E4%B8%AD%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">Dubbo中SPI扩展机制详解</a></h1>
	<b><time>2017-02-18 23:13:34</time></b>
	
	<a href="/tags/dubbo-SPI">dubbo SPI</a>
	
	<a href="/tags/dubbo-%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6">dubbo 扩展机制</a>
	
	<a href="/tags/dubbo%E6%BA%90%E7%A0%81">dubbo源码</a>
	
	<div>
		<p>前面我们了解过了Java的SPI扩展机制，对于Java扩展机制的原理以及优缺点也有了大概的了解，这里继续深入一下Dubbo的扩展点加载机制。</p>
		
			<a href="https://cxis.me/2017/02/18/Dubbo%E4%B8%ADSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2017/02/15/Spring%E7%9A%84ApplicationContext%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">Spring的ApplicationContext事件机制</a></h1>
	<b><time>2017-02-15 19:04:30</time></b>
	
	<a href="/tags/Spring">Spring</a>
	
	<div>
		<p>ApplicationContext中事件处理是由ApplicationEvent类和ApplicationListener接口来提供的。如果一个Bean实现了ApplicationListener接口，并且已经发布到容器中去，每次ApplicationContext发布一个ApplicationEvent事件，这个Bean就会接到通知。Spring事件机制是观察者模式的实现。</p>
		
			<a href="https://cxis.me/2017/02/15/Spring%E7%9A%84ApplicationContext%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2017/02/12/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Spring中Bean的生命周期</a></h1>
	<b><time>2017-02-12 22:02:37</time></b>
	
	<a href="/tags/Spring">Spring</a>
	
	<div>
		<p>BeanFactory和ApplicationContext是Spring中两种很重要的容器，前者提供了最基本的依赖注入的支持，后者在继承前者的基础上进行了功能的拓展，增加了事件传播，资源访问，国际化的支持等功能。同时两者的生命周期也稍微有些不同。</p>
		
			<a href="https://cxis.me/2017/02/12/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2017/02/10/Spring%E4%B8%ADIOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/">Spring中IOC容器的初始化过程</a></h1>
	<b><time>2017-02-10 23:59:13</time></b>
	
	<a href="/tags/Spring">Spring</a>
	
	<div>
		<p>Spring IOC容器初始化过程分为Resource定位，载入解析，注册。IOC容器初始化过程中不包含Bean的依赖注入。Bean的依赖注入一般会发生在第一次通过getBean向容器索取Bean的时候。</p>
		
			<a href="https://cxis.me/2017/02/10/Spring%E4%B8%ADIOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2016/12/27/SNMP-MIB-SNMP4J%E7%AE%80%E4%BB%8B/">SNMP-MIB-SNMP4J简介</a></h1>
	<b><time>2016-12-27 15:15:15</time></b>
	
	<a href="/tags/SNMP">SNMP</a>
	
	<div>
		<p>SNMP全称Simple Network Management Protocol，简单网络管理协议。是TCP/IP协议的一部分，属于应用层协议。SNMP协议主要用来解决网络设备的管理，大多数的网络管理系统都是基于SNMP协议。通过该协议可以实现在被管理的设备上获取各种参数，还可以设置修改这些参数。</p>
		
			<a href="https://cxis.me/2016/12/27/SNMP-MIB-SNMP4J%E7%AE%80%E4%BB%8B/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2016/12/15/volatile%E7%AE%80%E4%BB%8B/">volatile简介</a></h1>
	<b><time>2016-12-15 16:55:57</time></b>
	
	<a href="/tags/volatile%E7%AE%80%E4%BB%8B">volatile简介</a>
	
	<div>
		<p>Java允许线程访问共享变量。作为规则，为了确保共享变量被一致的和可靠的更新，线程应该确保它获得一个排它锁单独的获取这个变量。Java提供了第二种机制即volatile关键字，在某些情况下比锁更加方便。一个字段可以被声明为volatile，在这种情况下，Java内存模型确保所有线程看到的变量值都一样。（<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">Java语言规范</a>）</p>
		
			<a href="https://cxis.me/2016/12/15/volatile%E7%AE%80%E4%BB%8B/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="https://cxis.me/2016/12/05/ThreadLocal%E7%AE%80%E4%BB%8B/">ThreadLocal简介</a></h1>
	<b><time>2016-12-05 20:55:59</time></b>
	
	<a href="/tags/ThreadLocal%E7%AE%80%E4%BB%8B">ThreadLocal简介</a>
	
	<div>
		<h1 id="threadlocal简介">ThreadLocal简介</h1>
<p>Java中的ThreadLocal类给每个线程分配一个只属于该线程的变量副本，可以用来实现线程间的数据隔离，当前线程的变量不能被其他线程访问。</p>
		
			<a href="https://cxis.me/2016/12/05/ThreadLocal%E7%AE%80%E4%BB%8B/">Read more...</a>
		
	</div>
</article>

		
		<div>

	<a href="/page/18/">Previous Page</a>

19 of 24

	<a href="/page/20/">Next Page</a>

</div>

	</main>

	<footer>
	<p>&copy; 2021 <a href="https://cxis.me/"><b>cxis</b></a>.
	<a href="https://gohugo.io/"><b>Hugo</b></a>.
	<a href="https://github.com/colorchestra/smol"><b>Smol</b></a>.
	<a href="https://github.com/dachengxi"><b>Github</b></a>.
	</p>
</footer>

</body>
<script>
    window.MathJax = {
    tex: {
      tags: 'ams',  
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    },
  };
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.1.2/es5/tex-mml-svg.min.js" integrity="sha512-cvY8FLZ100SA0lUHyX38BDEr1rz0AKP6Iz+t5yfOPOyuKX72RNHIuPGH/+ScEsbKBhngYhKJSaFbtKet0te1Sw==" crossorigin="anonymous"></script>
</html>
