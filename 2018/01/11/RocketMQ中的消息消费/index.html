<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>RocketMQ中的消息消费</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
	=================<br>
	== <a href="https://cxis.me/">Time Stream</a> ==<br>
	=================
	<div style="float: right;">一个小学生</div><br>
	<p>
	<nav>
			<a href="/"><b>Start</b></a>.
			
			
			<a href="/posts/"><b>Posts</b></a>.
			
			<a href="/categories"><b>Categories</b></a>.
			
			<a href="/tags"><b>Tags</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>RocketMQ中的消息消费</h1>
			<b><time>2018-01-11 21:46:55</time></b>
		       
		           <a href="/tags/RocketMQ">RocketMQ</a>
        	       

			<div>
				<p>RocketMQ的消息消费学习。</p>
<p>一个消费组内可以包含多个消费者，每个消费组可订阅多个Topic。消费组之间有集群模式和广播模式：</p>
<ul>
<li>集群模式，Topic下的同一条消息只允许被其中一个消费者消费。</li>
<li>广播模式，Topic下的同一条消息被集群内所有消费者消费一次。</li>
</ul>
<p>消息服务器与消费者之间的消息传送有推模式和拉模式：</p>
<ul>
<li>拉模式，消费者主动发起拉消息的请求</li>
<li>推模式，消息到达消息服务器后，推送给消息消费者，RocketMQ的推模式基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务</li>
</ul>
<p>一个消息队列同一时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p>
<p>RocketMQ支持局部顺序消息消费，保证同一消息队列上的消息顺序消费。不支持全局顺序消费，如果要实现某个Topic的全局顺序消费，可将该Topic的队列设置为1，牺牲了高可用性。</p>
<h1 id="消费者启动流程">消费者启动流程</h1>
<ul>
<li>构建主题订阅信息SubscriptionData并加入到RebalanceImpl订阅消息中，订阅信息主要有通过subscribe方法订阅，订阅重试主题消息。</li>
<li>初始化MQClientInstance、RebalanceImpl等</li>
<li>初始化消息进度，集群模式的消息进度存储在Broker上，广播模式的消费进度存储在消费端。</li>
<li>根据是否是顺序消费，创建消费端消费线程服务。</li>
<li>向MQClientInstance注册消费者，并启动MQClientInstance，MQClientInstance在一个JVM只存在一个实例。</li>
</ul>
<h1 id="消息拉取">消息拉取</h1>
<ul>
<li>封装拉取消息的请求</li>
<li>消息服务器查找消息，返回</li>
<li>客户端处理拉取到的消息</li>
</ul>
<h1 id="消息队列负载和重新分布机制">消息队列负载和重新分布机制</h1>
<p>消息队列重新分布是由RebalanceService线程来实现，每隔20s执行一次doRebalance方法。</p>
<p>RocketMQ默认提供5中分分配算法：</p>
<ul>
<li>平均分配，如果有8个消费队列q1，q2，q3，q4，q5，q6，q7，q8，有三个消费者c1，c2，c3，则消息队列分配如下：c1对应q1，q2，q3；c2对应q4，q5，q6；c3对应q8</li>
<li>平均轮询分配，消息队列分配如下：c1对应q1，q4，q7；c2对应q2，q5，q8；c3对应q3，q6</li>
<li>一致性哈希，不推荐，消息队列负载信息不容易跟踪</li>
<li>根据配置，为每个消费者配置固定的消息队列</li>
<li>根据Broker部署机房名，对每个消费者负责不同的Broker上的队列</li>
</ul>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/2020/11/02/MyBatis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/">MyBatis启动过程介绍</a></li>
				
				<li><a href="/2020/10/26/SpringBoot%E4%B8%AD%E6%89%A9%E5%B1%95%E7%82%B9%E6%B1%87%E6%80%BB/">SpringBoot中扩展点汇总</a></li>
				
				<li><a href="/2020/08/26/Spring%E4%B8%AD%E5%AF%B9Groovy%E6%94%AF%E6%8C%81%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Spring中对Groovy支持的源码分析</a></li>
				
				<li><a href="/2020/08/25/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8Groovy%E7%9A%84%E7%A4%BA%E4%BE%8B/">Spring中使用Groovy的示例</a></li>
				
				<li><a href="/2020/05/05/Spring%E4%B8%ADPlaceholder%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/">Spring中Placeholder的解析过程</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2021 <a href="https://cxis.me/"><b>cxis</b></a>.
	<a href="https://gohugo.io/"><b>Hugo</b></a>.
	<a href="https://github.com/colorchestra/smol"><b>Smol</b></a>.
	<a href="https://github.com/dachengxi"><b>Github</b></a>.
	</p>
</footer>

</body>
</html>
